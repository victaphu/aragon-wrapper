{"version":3,"sources":["../../../src/rpc/handlers/path.test.js"],"names":["test","afterEach","always","sinon","restore","t","plan","appAddress","pathContextMock","requestStub","params","proxyStub","address","appContextPoolStub","get","stub","withArgs","APP_CONTEXTS","PATH","returns","wrapperStub","appContextPool","result","emitIndex","subscribe","value","deepEqual","fail","newPath","mockResponseSymbol","Symbol","requestAppPath","response","true","calledOnceWith","is","throwsAsync","message"],"mappings":"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","sourcesContent":["import test from 'ava'\nimport sinon from 'sinon'\nimport { of } from 'rxjs'\n\nimport { APP_CONTEXTS } from '../../apps'\nimport path from './path'\n\ntest.afterEach.always(() => {\n  sinon.restore()\n})\n\ntest(\"should return an observable for the app's paths on observe\", async (t) => {\n  t.plan(3)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const pathContextMock = of('/', '/page1', '/page2')\n  const requestStub = {\n    params: ['observe']\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n  const appContextPoolStub = {\n    get: sinon\n      .stub()\n      .withArgs(appAddress, APP_CONTEXTS.PATH)\n      .returns(pathContextMock)\n  }\n  const wrapperStub = {\n    appContextPool: appContextPoolStub\n  }\n\n  // act\n  const result = path(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, '/')\n    } else if (emitIndex === 1) {\n      t.deepEqual(value, '/page1')\n    } else if (emitIndex === 2) {\n      t.deepEqual(value, '/page2')\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n})\n\ntest('should request app path on modify', async (t) => {\n  t.plan(2)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const newPath = '/new'\n  const requestStub = {\n    params: ['modify', newPath]\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n  const mockResponseSymbol = Symbol('response')\n  const wrapperStub = {\n    requestAppPath: sinon.stub().returns(mockResponseSymbol)\n  }\n\n  // act\n  const response = path(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  t.true(wrapperStub.requestAppPath.calledOnceWith(appAddress, newPath))\n  t.is(response, mockResponseSymbol)\n})\n\ntest('should error on invalid path request', async (t) => {\n  t.plan(1)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const requestStub = {\n    params: ['notHandled']\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n\n  // assert\n  await t.throwsAsync(\n    path(requestStub, proxyStub),\n    { message: 'Invalid path operation' }\n  )\n})\n"],"file":"path.test.js"}