{"version":3,"sources":["../../../src/rpc/handlers/get-apps.js"],"names":["transformAppInformation","app","getContentPathFn","abi","appId","content","contractAddress","icons","identifier","isForwarder","kernelAddress","name","proxyAddress","roles","iconsWithBaseUrl","map","icon","src","_","appAddress","appImplementationAddress","Boolean","request","proxy","wrapper","operation","params","appCategory","undefined","apps","appWithIdentifier$","appIdentifiers","pipe","identifiers","apm","getContentPath","app$","find","address","Promise","reject","Error"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AACA;;;;;;AAEA;AACA,SAASA,uBAAT,CAAkCC,GAAG,GAAG,EAAxC,EAA4CC,gBAA5C,EAA8D;AAC5D,QAAM;AACJC,IAAAA,GADI;AAEJC,IAAAA,KAFI;AAGJC,IAAAA,OAHI;AAIJC,IAAAA,eAJI;AAKJC,IAAAA,KALI;AAMJC,IAAAA,UANI;AAOJC,IAAAA,WAPI;AAQJC,IAAAA,aARI;AASJC,IAAAA,IATI;AAUJC,IAAAA,YAVI;AAWJC,IAAAA;AAXI,MAYFZ,GAZJ;AAcA,MAAIa,gBAAJ;;AACA,MAAI;AACFA,IAAAA,gBAAgB,GAAGP,KAAK,CAACQ,GAAN,CAAWC,IAAD,oCACrBA,IADqB;AACfC,MAAAA,GAAG,EAAEf,gBAAgB,CAACG,OAAD,EAAUW,IAAI,CAACC,GAAf;AADN,MAAV,CAAnB;AAGD,GAJD,CAIE,OAAOC,CAAP,EAAU,CAAE;;AAEd,SAAO;AACLf,IAAAA,GADK;AAELK,IAAAA,UAFK;AAGLE,IAAAA,aAHK;AAILC,IAAAA,IAJK;AAKLQ,IAAAA,UAAU,EAAEP,YALP;AAMLR,IAAAA,KAAK,EAAEA,KANF;AAOLgB,IAAAA,wBAAwB,EAAEd,eAPrB;AAQLC,IAAAA,KAAK,EAAEO,gBARF;AASLL,IAAAA,WAAW,EAAEY,OAAO,CAACZ,WAAD,CATf;AAULI,IAAAA;AAVK,GAAP;AAYD;;AAEc,kBAAUS,OAAV,EAAmBC,KAAnB,EAA0BC,OAA1B,EAAmC;AAChD,QAAMC,SAAS,GAAGH,OAAO,CAACI,MAAR,CAAe,CAAf,CAAlB;AACA,MAAIC,WAAW,GAAGL,OAAO,CAACI,MAAR,CAAe,CAAf,CAAlB;;AACA,MAAIC,WAAW,KAAK,KAAhB,IAAyBA,WAAW,KAAK,SAA7C,EAAwD;AACtDA,IAAAA,WAAW,GAAG,KAAd;AACD,GAL+C,CAOhD;;;AACA,MAAIF,SAAS,KAAKG,SAAlB,EAA6B;AAC3B,WAAOJ,OAAO,CAACK,IAAf;AACD;;AAED,QAAMC,kBAAkB,GAAG,yBAAcN,OAAO,CAACK,IAAtB,EAA4BL,OAAO,CAACO,cAApC,EAAoDC,IAApD,CACzB,oBAAI,CAAC,CAACH,IAAD,EAAOI,WAAP,CAAD,KACFJ,IAAI,CAACd,GAAL,CAAUd,GAAD,oCAEFA,GAFE;AAGLO,IAAAA,UAAU,EAAEyB,WAAW,CAAChC,GAAG,CAACW,YAAL;AAHlB,IAAT,CADF,CADyB,CAA3B;AAWA,QAAMV,gBAAgB,GAAGsB,OAAO,CAACU,GAAR,CAAYC,cAArC;AACA,QAAMC,IAAI,GAAGT,WAAW,KAAK,SAAhB,GACTG,kBAAkB,CAACE,IAAnB,CACA,oBAAIH,IAAI,IAAIA,IAAI,CAACQ,IAAL,CAAUpC,GAAG,IAAI,2BAAeA,GAAG,CAACW,YAAnB,EAAiCW,KAAK,CAACe,OAAvC,CAAjB,CAAZ,CADA,EAEA,oBAAKrC,GAAD,IAASD,uBAAuB,CAACC,GAAD,EAAMC,gBAAN,CAApC,CAFA,CADS,GAKT4B,kBAAkB,CAACE,IAAnB,CACA,oBAAKH,IAAD,IAAUA,IAAI,CAACd,GAAL,CAAUd,GAAD,IAASD,uBAAuB,CAACC,GAAD,EAAMC,gBAAN,CAAzC,CAAd,CADA,CALJ;;AAQA,MAAIuB,SAAS,KAAK,SAAlB,EAA6B;AAC3B,WAAOW,IAAP;AACD;;AACD,MAAIX,SAAS,KAAK,KAAlB,EAAyB;AACvB,WAAOW,IAAI,CAACJ,IAAL,CAAU,uBAAV,CAAP;AACD;;AAED,SAAOO,OAAO,CAACC,MAAR,CACL,IAAIC,KAAJ,CAAU,4BAAV,CADK,CAAP;AAGD","sourcesContent":["import { combineLatest } from 'rxjs'\nimport { first, map } from 'rxjs/operators'\nimport { addressesEqual } from '../../utils'\n\n// Extract just a few important details about the current app to decrease API surface area\nfunction transformAppInformation (app = {}, getContentPathFn) {\n  const {\n    abi,\n    appId,\n    content,\n    contractAddress,\n    icons,\n    identifier,\n    isForwarder,\n    kernelAddress,\n    name,\n    proxyAddress,\n    roles\n  } = app\n\n  let iconsWithBaseUrl\n  try {\n    iconsWithBaseUrl = icons.map((icon) =>\n      ({ ...icon, src: getContentPathFn(content, icon.src) })\n    )\n  } catch (_) {}\n\n  return {\n    abi,\n    identifier,\n    kernelAddress,\n    name,\n    appAddress: proxyAddress,\n    appId: appId,\n    appImplementationAddress: contractAddress,\n    icons: iconsWithBaseUrl,\n    isForwarder: Boolean(isForwarder),\n    roles\n  }\n}\n\nexport default function (request, proxy, wrapper) {\n  const operation = request.params[0]\n  let appCategory = request.params[1]\n  if (appCategory !== 'all' && appCategory !== 'current') {\n    appCategory = 'all'\n  }\n\n  // Backwards compatibility with initial RPC API (no parameters passed)\n  if (operation === undefined) {\n    return wrapper.apps\n  }\n\n  const appWithIdentifier$ = combineLatest(wrapper.apps, wrapper.appIdentifiers).pipe(\n    map(([apps, identifiers]) =>\n      apps.map((app) =>\n        ({\n          ...app,\n          identifier: identifiers[app.proxyAddress]\n        })\n      )\n    )\n  )\n\n  const getContentPathFn = wrapper.apm.getContentPath\n  const app$ = appCategory === 'current'\n    ? appWithIdentifier$.pipe(\n      map(apps => apps.find(app => addressesEqual(app.proxyAddress, proxy.address))),\n      map((app) => transformAppInformation(app, getContentPathFn))\n    )\n    : appWithIdentifier$.pipe(\n      map((apps) => apps.map((app) => transformAppInformation(app, getContentPathFn)))\n    )\n  if (operation === 'observe') {\n    return app$\n  }\n  if (operation === 'get') {\n    return app$.pipe(first())\n  }\n\n  return Promise.reject(\n    new Error('Invalid get apps operation')\n  )\n}\n"],"file":"get-apps.js"}