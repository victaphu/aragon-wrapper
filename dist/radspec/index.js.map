{"version":3,"sources":["../../src/radspec/index.js"],"names":["tryEvaluatingRadspec","intent","wrapper","apps","pipe","toPromise","app","find","proxyAddress","to","appsToSearch","foundMethod","reduce","found","method","data","abi","undefined","evaluatedNotice","notice","network","radspec","evaluate","transaction","ethNode","web3","currentProvider","currency","nativeCurrency","err","console","error","description","tryDescribingUpdateAppIntent","upgradeIntentParams","appId","appAddress","repoAddress","ens","resolve","repo","version","latestVersion","tryDescribingUpgradeOrganizationBasket","intents","upgradedKnownAppIds","map","filter","knownAppIds","includes","length","from"],"mappings":"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","sourcesContent":["import { first } from 'rxjs/operators'\nimport * as radspec from 'radspec'\nimport { getRepoLatestVersionForContract, makeRepoProxy } from '../core/apm/repo'\nimport { addressesEqual } from '../utils'\nimport { findAppMethodFromData, knownAppIds } from '../utils/apps'\nimport { filterAndDecodeAppUpgradeIntents } from '../utils/intents'\n\n/**\n * Attempt to describe intent via radspec.\n *\n * @param  {Object} intent transaction intent\n * @param  {Object} wrapper\n * @return {Promise<Object>} Decorated intent with description, if one could be made\n */\nexport async function tryEvaluatingRadspec (intent, wrapper) {\n  const apps = await wrapper.apps.pipe(first()).toPromise()\n  const app = apps.find(app => addressesEqual(app.proxyAddress, intent.to))\n\n  // If the intent matches an installed app, use only that app to search for a\n  // method match, otherwise fallback to searching all installed apps\n  const appsToSearch = app ? [app] : apps\n  const foundMethod = appsToSearch.reduce((found, app) => {\n    if (found) { return found }\n\n    const method = findAppMethodFromData(app, intent.data)\n    if (method) {\n      return {\n        method,\n        // This is not very nice, but some apps don't have ABIs attached to their function\n        // declarations and so we have to fall back to using their full app ABI\n        // TODO: define a more concrete schema around the artifact.json's `function.abi`\n        abi: method.abi ? [method.abi] : app.abi\n      }\n    }\n  }, undefined)\n\n  const { abi, method } = foundMethod || {}\n\n  let evaluatedNotice\n  if (method && method.notice) {\n    try {\n      const network = await wrapper.network.pipe(first()).toPromise()\n      evaluatedNotice = await radspec.evaluate(\n        method.notice,\n        {\n          abi,\n          transaction: intent\n        },\n        {\n          ethNode: wrapper.web3.currentProvider,\n          currency: network.nativeCurrency\n        }\n      )\n    } catch (err) {\n      console.error(`Could not evaluate a description for given transaction data: ${intent.data}`, err)\n    }\n  }\n\n  return {\n    ...intent,\n    description: evaluatedNotice\n  }\n}\n\n/**\n * Attempt to describe a setApp() intent. Only describes the APP_BASE namespace.\n *\n * @param  {Object} intent transaction intent\n * @param  {Object} wrapper\n * @return {Promise<Object>} Decorated intent with description, if one could be made\n */\nexport async function tryDescribingUpdateAppIntent (intent, wrapper) {\n  const upgradeIntentParams = (await filterAndDecodeAppUpgradeIntents([intent], wrapper))[0]\n  if (!upgradeIntentParams) return\n\n  const { appId, appAddress } = upgradeIntentParams\n  // Fetch aragonPM information\n  const repoAddress = await wrapper.ens.resolve(appId)\n  const repo = makeRepoProxy(repoAddress, wrapper.web3)\n  const { version: latestVersion } = await getRepoLatestVersionForContract(repo, appAddress)\n\n  return {\n    ...intent,\n    description: `Upgrade ${appId} app instances to v${latestVersion}`\n  }\n}\n\n/**\n * Attempt to parse a complete organization upgrade intent\n *\n * @param  {Array<Object>} intents intent basket\n * @param  {Object} wrapper\n * @return {Promise<Object>} Decorated intent with description, if one could be made\n */\nexport async function tryDescribingUpgradeOrganizationBasket (intents, wrapper) {\n  const upgradedKnownAppIds = (await filterAndDecodeAppUpgradeIntents(intents, wrapper))\n    .map(({ appId }) => appId)\n    // Take intersection with knownAppIds\n    .filter(\n      appId => knownAppIds.includes(appId)\n    )\n\n  if (\n    // All intents are for upgrading known apps\n    intents.length === upgradedKnownAppIds.length &&\n    // All known apps are being upgraded\n    knownAppIds.length === upgradedKnownAppIds.length\n  ) {\n    return {\n      description: 'Upgrade organization to Aragon 0.8 Camino',\n      from: intents[0].from,\n      to: intents[0].to\n    }\n  }\n}\n\nexport { postprocessRadspecDescription } from './postprocess'\n"],"file":"index.js"}