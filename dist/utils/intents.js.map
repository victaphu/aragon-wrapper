{"version":3,"sources":["../../src/utils/intents.js"],"names":["doIntentPathsMatch","intentPaths","individualPaths","map","path","to","slice","join","Set","size","Boolean","filterAndDecodeAppUpgradeIntents","intents","wrapper","kernelApp","getApp","kernelProxy","address","filter","intent","data","_","namespace"],"mappings":";;;;;;;;AAAA;;AAMO,SAASA,kBAAT,CAA6BC,WAA7B,EAA0C;AAC/C,QAAMC,eAAe,GAAGD,WAAW,CACjC;AADiC,GAEhCE,GAFqB,CAEjBC,IAAI,IACPA,IAAI,CAACD,GAAL,CAAS,CAAC;AAAEE,IAAAA;AAAF,GAAD,KAAYA,EAArB,CAHoB,EAKtB;AALsB,GAMrBF,GANqB,CAMjBC,IAAI,IAAIA,IAAI,CAACE,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CANS,EAOtB;AAPsB,GAQrBH,GARqB,CAQjBC,IAAI,IAAIA,IAAI,CAACG,IAAL,CAAU,GAAV,CARS,CAAxB,CAD+C,CAW/C;AACA;AACA;;AACA,SAAQ,IAAIC,GAAJ,CAAQN,eAAR,CAAD,CAA2BO,IAA3B,KAAoC,CAApC,IAAyCC,OAAO,CAACR,eAAe,CAAC,CAAD,CAAhB,CAAvD;AACD;;AAEM,eAAeS,gCAAf,CAAiDC,OAAjD,EAA0DC,OAA1D,EAAmE;AACxE,QAAMC,SAAS,GAAG,MAAMD,OAAO,CAACE,MAAR,CAAeF,OAAO,CAACG,WAAR,CAAoBC,OAAnC,CAAxB;AAEA,SAAOL,OAAO,CACZ;AADY,GAEXM,MAFI,CAEIC,MAAD,IAAY,kCAAqBL,SAArB,EAAgCK,MAAhC,CAFf,EAGL;AAHK,GAIJhB,GAJI,CAICgB,MAAD,IAAY;AACf,QAAI;AACF,aAAO,0CAA6BA,MAAM,CAACC,IAApC,CAAP;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU,CAAE;;AAEd,WAAO,EAAP;AACD,GAVI,EAWL;AAXK,GAYJH,MAZI,CAYG,CAAC;AAAEI,IAAAA;AAAF,GAAD,KAAmB,sCAAyBA,SAAzB,CAZtB,CAAP;AAaD","sourcesContent":["import {\n  decodeKernelSetAppParameters,\n  isKernelAppCodeNamespace,\n  isKernelSetAppIntent\n} from '../core/aragonOS/kernel'\n\nexport function doIntentPathsMatch (intentPaths) {\n  const individualPaths = intentPaths\n    // Map each path to just be an array of destination addresses\n    .map(path =>\n      path.map(({ to }) => to)\n    )\n    // Ignore the final intent target, as the path is everything \"before\" that target\n    .map(path => path.slice(0, -1))\n    // Take each array of destination addresses and create a single string\n    .map(path => path.join('.'))\n\n  // Check if they all match by seeing if a unique set of the individual path\n  // strings is a single path\n  // Also make sure that there was indeed an actual path found\n  return (new Set(individualPaths)).size === 1 && Boolean(individualPaths[0])\n}\n\nexport async function filterAndDecodeAppUpgradeIntents (intents, wrapper) {\n  const kernelApp = await wrapper.getApp(wrapper.kernelProxy.address)\n\n  return intents\n    // Filter for setApp() calls to the kernel\n    .filter((intent) => isKernelSetAppIntent(kernelApp, intent))\n    // Try to decode setApp() params\n    .map((intent) => {\n      try {\n        return decodeKernelSetAppParameters(intent.data)\n      } catch (_) {}\n\n      return {}\n    })\n    // Filter for changes to APP_BASES_NAMESPACE\n    .filter(({ namespace }) => isKernelAppCodeNamespace(namespace))\n}\n"],"file":"intents.js"}