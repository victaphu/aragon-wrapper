{"version":3,"sources":["../../src/utils/FileFetcher.js"],"names":["axios","require","sanitizePath","path","replace","sanitizeUrl","url","startsWith","endsWith","FileFetcher","constructor","ipfsGateway","providers","Map","set","gateway","getFullPath","provider","location","supportsProvider","Error","baseLocation","get","fetch","config","response","responseType","transformResponse","data","has"],"mappings":";;;;;;;;;;;;;;;AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,SAASC,YAAT,CAAuBC,IAAvB,EAA6B;AAC3B;AACA,SAAOA,IAAI,CAACC,OAAL,CAAa,QAAb,EAAuB,EAAvB,CAAP;AACD;;AAED,SAASC,WAAT,CAAsBC,GAAtB,EAA2B;AACzB;AACA,MAAI,CAACA,GAAG,CAACC,UAAJ,CAAe,SAAf,CAAD,IAA8B,CAACD,GAAG,CAACC,UAAJ,CAAe,UAAf,CAAnC,EAA+D;AAC7DD,IAAAA,GAAG,GAAI,UAASA,GAAI,EAApB;AACD;;AACD,MAAI,CAACA,GAAG,CAACE,QAAJ,CAAa,GAAb,CAAL,EAAwB;AACtBF,IAAAA,GAAG,GAAI,GAAEA,GAAI,GAAb;AACD;;AAED,SAAOA,GAAP;AACD;;AAEc,MAAMG,WAAN,CAAkB;AAC/BC,EAAAA,WAAW,CAAE;AAAEC,IAAAA,WAAW,GAAG;AAAhB,MAAuB,EAAzB,EAA6B;AACtC,SAAKC,SAAL,GAAiB,IAAIC,GAAJ,CAAQ,CAAC,CAAC,MAAD,CAAD,CAAR,CAAjB;;AAEA,QAAIF,WAAJ,EAAiB;AACf,WAAKC,SAAL,CAAeE,GAAf,CAAmB,MAAnB,EAA2B;AAAEC,QAAAA,OAAO,EAAEV,WAAW,CAACM,WAAD;AAAtB,OAA3B;AACD;AACF;;AAEDK,EAAAA,WAAW,CAAEC,QAAF,EAAYC,QAAZ,EAAsBf,IAAtB,EAA4B;AACrC,QAAI,CAAC,KAAKgB,gBAAL,CAAsBF,QAAtB,CAAL,EAAsC;AACpC,YAAM,IAAIG,KAAJ,CAAW,2BAA0BH,QAAS,EAA9C,CAAN;AACD,KAHoC,CAKrC;;;AACA,UAAMI,YAAY,GAAGJ,QAAQ,KAAK,MAAb,GAChB,GAAE,KAAKL,SAAL,CAAeU,GAAf,CAAmB,MAAnB,EAA2BP,OAAQ,GAAEG,QAAS,EADhC,GAEjBA,QAFJ;AAIA,WAAQ,GAAEb,WAAW,CAACgB,YAAD,CAAe,GAAEnB,YAAY,CAACC,IAAD,CAAO,EAAzD;AACD;;AAEU,QAALoB,KAAK,CAAEN,QAAF,EAAYC,QAAZ,EAAsBf,IAAtB,EAA4BqB,MAA5B,EAAoC;AAC7C,UAAMC,QAAQ,GAAG,MAAMzB,KAAK,CAAC,KAAKgB,WAAL,CAAiBC,QAAjB,EAA2BC,QAA3B,EAAqCf,IAArC,CAAD,kCACvBqB,MADuB;AAE1BE,MAAAA,YAAY,EAAE,MAFY;AAI1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,MAAAA,iBAAiB,EAAE;AAZO,OAA5B;AAcA,WAAOF,QAAQ,CAACG,IAAhB;AACD;;AAEDT,EAAAA,gBAAgB,CAAEF,QAAF,EAAY;AAC1B,WAAO,KAAKL,SAAL,CAAeiB,GAAf,CAAmBZ,QAAnB,CAAP;AACD;;AA1C8B","sourcesContent":["const axios = require('axios')\n\nfunction sanitizePath (path) {\n  // Disallow a path being declared for the root or navigating to sibling paths\n  return path.replace(/^[./]+/, '')\n}\n\nfunction sanitizeUrl (url) {\n  // Sanitize url to make sure it has a protocol and ends with a /\n  if (!url.startsWith('http://') && !url.startsWith('https://')) {\n    url = `http://${url}`\n  }\n  if (!url.endsWith('/')) {\n    url = `${url}/`\n  }\n\n  return url\n}\n\nexport default class FileFetcher {\n  constructor ({ ipfsGateway = '' } = {}) {\n    this.providers = new Map([['http']])\n\n    if (ipfsGateway) {\n      this.providers.set('ipfs', { gateway: sanitizeUrl(ipfsGateway) })\n    }\n  }\n\n  getFullPath (provider, location, path) {\n    if (!this.supportsProvider(provider)) {\n      throw new Error(`Provider not supported: ${provider}`)\n    }\n\n    // When IPFS is the provider, the declared location is a CID\n    const baseLocation = provider === 'ipfs'\n      ? `${this.providers.get('ipfs').gateway}${location}`\n      : location\n\n    return `${sanitizeUrl(baseLocation)}${sanitizePath(path)}`\n  }\n\n  async fetch (provider, location, path, config) {\n    const response = await axios(this.getFullPath(provider, location, path), {\n      ...config,\n      responseType: 'text',\n\n      // This is needed to disable the default behavior of axios, which\n      // always tries to use JSON.parse() even if `responseType` is \"text\".\n      //\n      // See:\n      //   https://github.com/axios/axios/issues/907#issuecomment-322054564\n      //\n      // Although the comment states that 'undefined' should work, setting 'undefined' on\n      // axios@0.19.0 does not override the default, so we have to use null\n      transformResponse: null\n    })\n    return response.data\n  }\n\n  supportsProvider (provider) {\n    return this.providers.has(provider)\n  }\n}\n"],"file":"FileFetcher.js"}