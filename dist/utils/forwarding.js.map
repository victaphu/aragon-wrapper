{"version":3,"sources":["../../src/utils/forwarding.js"],"names":["FORWARD_SIG","isValidForwardCall","calldata","replace","selector","substring","evmscriptData","length","parseForwardCall","offset","parseInt","startIndex","dataLength"],"mappings":";;;;;;;;AAAO,MAAMA,WAAW,GAAG,YAApB,C,CAAiC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACO,SAASC,kBAAT,CAA6BC,QAA7B,EAAuC;AAC5C;AACAA,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,CAAX,CAF4C,CAG5C;;AACA,QAAMC,QAAQ,GAAGF,QAAQ,CAACG,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,CAAjB,CAJ4C,CAK5C;;AACA,QAAMC,aAAa,GAAGJ,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CAAtB,CAN4C,CAO5C;AACA;;AACA,SAAQ,KAAID,QAAS,EAAd,KAAoBJ,WAApB,IAAmCM,aAAa,CAACC,MAAd,IAAwB,GAAlE;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASC,gBAAT,CAA2BN,QAA3B,EAAqC;AAC1C;AACAA,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,CAAX,CAF0C,CAG1C;;AACA,QAAMG,aAAa,GAAGJ,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CAAtB,CAJ0C,CAK1C;AACA;;AACA,QAAMI,MAAM,GAAGC,QAAQ,CAAE,KAAIJ,aAAa,CAACD,SAAd,CAAwB,CAAxB,EAA2B,EAA3B,CAA+B,EAArC,EAAwC,EAAxC,CAAR,GAAsD,CAArE,CAP0C,CAQ1C;;AACA,QAAMM,UAAU,GAAGF,MAAM,GAAG,EAA5B,CAT0C,CAU1C;AACA;;AACA,QAAMG,UAAU,GAAGF,QAAQ,CAAE,KAAIJ,aAAa,CAACD,SAAd,CAAwBI,MAAxB,EAAgCE,UAAhC,CAA4C,EAAlD,EAAqD,EAArD,CAAR,GAAmE,CAAtF,CAZ0C,CAa1C;;AACA,SAAQ,KAAIL,aAAa,CAACD,SAAd,CAAwBM,UAAxB,EAAoCA,UAAU,GAAGC,UAAjD,CAA6D,EAAzE;AACD","sourcesContent":["export const FORWARD_SIG = '0xd948d468' // function forward(bytes)\n\n/**\n * Tells if the given calldata (as a bytes string) is a valid invocation of\n * `forward(bytes)`.\n *\n * It will return true only if the given calldata starts with the forward\n * function signature and follows with at least an empty bytes array properly\n * ABI encoded following the convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {boolean}\n */\nexport function isValidForwardCall (calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, '')\n  // First 4 bytes represent the function selector\n  const selector = calldata.substring(0, 8)\n  // Drop selector and grab the argument data\n  const evmscriptData = calldata.substring(8)\n  // Since arrays of bytes are encoded following the [offset][length][data]\n  // format, we expect it to have at least two words length (empty data scenario)\n  return `0x${selector}` === FORWARD_SIG && evmscriptData.length >= 128\n}\n\n/**\n * Parse the evmscript of a forward call following the byte ABI encoding\n * convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {string} Array of bytes representing the forwarded evmscript\n */\nexport function parseForwardCall (calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, '')\n  // Drop function selector and grab the argument data (of type bytes)\n  const evmscriptData = calldata.substring(8)\n  // Parse first word of the bytes array to get data offset\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n  const offset = parseInt(`0x${evmscriptData.substring(0, 64)}`, 16) * 2\n  // The first word in the data is its length (uint256); actual data starts after\n  const startIndex = offset + 64\n  // Parse length of the data stored\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n  const dataLength = parseInt(`0x${evmscriptData.substring(offset, startIndex)}`, 16) * 2\n  // Grab the data stored in the bytes array\n  return `0x${evmscriptData.substring(startIndex, startIndex + dataLength)}`\n}\n"],"file":"forwarding.js"}