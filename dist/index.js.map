{"version":3,"sources":["../src/index.js"],"names":["detectProvider","web3","currentProvider","Aragon","constructor","daoAddress","options","defaultOptions","defaultGasPriceFn","provider","cache","forceLocalStorage","prefix","events","subscriptionDelayTime","Object","assign","configurationKeys","FORCE_LOCAL_STORAGE","SUBSCRIPTION_EVENT_DELAY","Number","isFinite","subscriptionEventDelay","Web3","ens","apm","ensRegistryAddress","ipfs","apmIpfsOptions","fetchTimeout","ipfsGateway","gateway","kernelProxy","cachePrefix","Cache","appContextPool","AppContextPool","init","aclAddress","call","_","Error","updateInitializationBlock","initAccounts","accounts","initAcl","acl","initIdentityProviders","initApps","initForwarders","initAppIdentifiers","initNetwork","network","initGuiStyle","guiStyle","pathIntents","Subject","transactions","signatures","fetchFromWeb3","providedAccounts","ReplaySubject","concat","eth","getAccounts","setAccounts","aclProxy","initializationBlock","SET_PERMISSION_EVENT","CHANGE_PERMISSION_MANAGER_EVENT","ACL_CACHE_KEY","REORG_SAFETY_BLOCK_AGE","currentBlock","getBlockNumber","cacheBlockHeight","Math","max","cachedAclState","get","permissions","cachedPermissions","blockNumber","cachedBlockNumber","pastEventsOptions","toBlock","fromBlock","undefined","pastEvents$","pastEvents","pipe","event","returnValues","currentEvents$","fetchedPermissions$","eventData","app","appPermissions","key","role","allowedEntitiesSet","Set","dotprop","allowed","add","entity","delete","set","Array","from","manager","connect","cachedPermissions$","isApp","kernelAddress","isKernelAddress","address","applicationInfoCache","AsyncRequestCache","cacheKey","appId","codeAddress","split","fetchLatestRepoContentForContract","resolve","proxyContractValueCache","proxyAddress","Promise","all","then","values","appProxy","appProxyForwarder","catch","isForwarder","installedApps$","keys","oldProxies","newProxies","length","oldSet","intersection","filter","newProxy","has","size","proxyAddresses","appsWithoutKernel","map","proxyValues","request","appProxies","updatedApps$","namespace","updateApps","setAppEvent","apps","setAppId","updated","updatedApps","apps$","appsWithInfo$","appInfo","isForwarderOverride","isArray","abi","some","type","name","installedRepoCache","Map","repo$","reduce","installedRepos","contractAddress","repos","newRepoAppIds","updatedRepoAppIds","forEach","repo","push","newRepos","repoProxy","repoAddress","err","console","error","update$","newRepo$","repoAddress$","version$","initialVersions","versionId","eventVersionId","timestamp","getBlock","versionIndex","findIndex","versionInfo","versions","newVersionInfo","newVersions","repoUpdate","updatedAppId","update","updatedRepoInfo","updatedRepoAppId","installedRepoInfo","baseRepoInfo","fetchVersionInfo","version","content","latestVersion","currentVersion","reverse","find","currentVersionInfoRequest","latestVersionInfoRequest","updatedRepo","repoIndex","nextRepos","asyncScheduler","leading","trailing","forwarders","appIdentifiers","BehaviorSubject","identifiers","identifier","setAppIdentifier","next","defaultIdentityProviders","LocalIdentityProvider","detectedIdentityProviders","identityProviders","identityProviderRegistrar","identityIntents","modifyAddressIdentity","metadata","providerName","modify","reject","resolveAddressIdentity","searchIdentities","searchTerm","search","requestAddressIdentityModification","removeLocalIdentities","addresses","localProvider","remove","getLocalIdentities","getAll","appearance","theme","setGuiStyle","id","getChainId","net","getNetworkType","requestAppPath","appAddress","path","getApp","setAppPath","emit","APP_CONTEXTS","PATH","runApp","toPromise","sandboxMessengerProvider","messenger","Messenger","request$","requests","proxy","wrapper","handlerSubscription","handlers","combineRequestHandlers","createRequestHandler","describeScript","describeTransaction","getApps","trigger","web3Eth","intent","signMessage","externalCall","externalEvents","externalIntent","externalPastEvents","appIdentifier","addressIdentity","subscribe","response","sendResponse","payload","shutdown","unsubscribe","shutdownAndClearCache","promise","startsWith","message","requestingApp","performTransactionPath","transactionPath","external","transaction","performACLIntent","method","params","getACLTransactionPath","getTransactionPath","destination","methodSignature","finalForwarder","account","calculateTransactionPath","describeTransactionPath","getExternalTransactionPath","methodAbiFragment","installedApp","tx","getTransactionPathForIntentBasket","intentBasket","checkMode","intentsToCheck","intentPaths","pathsMatch","sender","directTransactions","decoratedTransactions","applyTransactionGas","createForwarderTransaction","forwarderPath","slice","to","nextForwarder","lastStep","encodedLastStep","getPermissionManager","roleHash","aclAddr","allowDeprecated","roles","inputNames","inputs","input","appIndex","indexOf","roleIndex","decodeTransactionPath","script","segment","data","forwardedEvmScript","children","step","decoratedStep","description","processed","annotatedDescription","canForward","forwarder","Contract","methods","getDefaultGasPrice","gasLimit","isForwarding","pretransaction","estimatedGasLimit","estimateGas","gas","recommendedGasLimit","gasPrice","directTransaction","finalForwarderProvided","forwardersWithPermission","destinationPermissions","roleSig","bytes","allowedEntities","ANY_ENTITY","calculateForwardingPath","transactionWithFee","queue","forwarderWithPermission","nextQueue","shift","previousForwarder"],"mappings":"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","sourcesContent":["// Externals\nimport { asyncScheduler, concat, from, merge, of, BehaviorSubject, ReplaySubject, Subject } from 'rxjs'\nimport {\n  concatMap,\n  debounceTime,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  first,\n  map,\n  mergeAll,\n  mergeMap,\n  publishReplay,\n  scan,\n  startWith,\n  switchMap,\n  throttleTime,\n  withLatestFrom\n} from 'rxjs/operators'\nimport Web3 from 'web3'\nimport { isAddress } from 'web3-utils'\nimport dotprop from 'dot-prop'\n\n// RPC\nimport Messenger from '@aragon/rpc-messenger'\nimport * as handlers from './rpc/handlers'\n\nimport AppContextPool, { APP_CONTEXTS } from './apps'\nimport Cache from './cache'\nimport apm, { getApmInternalAppInfo } from './core/apm'\nimport { makeRepoProxy, getAllRepoVersions, getRepoVersionById } from './core/apm/repo'\nimport {\n  getAragonOsInternalAppInfo,\n  isAragonOsInternalApp\n} from './core/aragonOS'\nimport { isKernelAppCodeNamespace } from './core/aragonOS/kernel'\nimport { setConfiguration } from './configuration'\nimport * as configurationKeys from './configuration/keys'\nimport ens from './ens'\nimport { LocalIdentityProvider } from './identity'\nimport { getAbi } from './interfaces'\nimport {\n  postprocessRadspecDescription,\n  tryDescribingUpdateAppIntent,\n  tryDescribingUpgradeOrganizationBasket,\n  tryEvaluatingRadspec\n} from './radspec'\nimport {\n  ANY_ENTITY,\n  addressesEqual,\n  getCacheKey,\n  includesAddress,\n  makeAddressMapProxy,\n  makeProxy,\n  makeProxyFromAppABI,\n  AsyncRequestCache\n} from './utils'\nimport { findMethodAbiFragment } from './utils/abi'\nimport { findAppMethodFromSignature } from './utils/apps'\nimport { decodeCallScript, encodeCallScript, isCallScript } from './utils/callscript'\nimport { isValidForwardCall, parseForwardCall } from './utils/forwarding'\nimport { doIntentPathsMatch } from './utils/intents'\nimport {\n  applyForwardingFeePretransaction,\n  createDirectTransaction,\n  createDirectTransactionForApp,\n  createForwarderTransactionBuilder,\n  getRecommendedGasLimit\n} from './utils/transactions'\n\n// Try to get an injected web3 provider, return a public one otherwise.\nexport const detectProvider = () =>\n  typeof web3 !== 'undefined'\n    ? web3.currentProvider // eslint-disable-line\n    : 'wss://rinkeby.eth.aragon.network/ws'\n\n/**\n * An Aragon wrapper.\n *\n * @param {string} daoAddress\n *        The address of the DAO.\n * @param {Object} options\n *        Wrapper options.\n * @param {Object} options.apm\n *        Options for fetching information from aragonPM\n * @param {string} options.apm.ensRegistryAddress\n *        ENS registry for aragonPM\n * @param {Object} [options.apm.ipfs]\n *        IPFS provider config for aragonPM\n * @param {string} [options.apm.ipfs.gateway]\n *        IPFS gateway to fetch aragonPM artifacts from\n * @param {number} [options.apm.ipfs.fetchTimeout]\n *        Timeout for retrieving aragonPM artifacts from IPFS before failing\n * @param {Object} [options.cache]\n *        Options for the internal cache\n * @param {boolean} [options.cache.forceLocalStorage=false]\n *        Downgrade to localStorage even if IndexedDB is available\n * @param {Object} [options.events]\n *        Options for handling Ethereum events\n * @param {boolean} [options.events.subscriptionEventDelay]\n *        Time in ms to delay a new event from a contract subscription\n * @param {Function} [options.defaultGasPriceFn=function]\n *        A factory function to provide the default gas price for transactions.\n *        It can return a promise of number string or a number string. The function\n *        has access to a recommended gas limit which can be used for custom\n *        calculations. This function can also be used to get a good gas price\n *        estimation from a 3rd party resource.\n * @param {string|Object} [options.provider=web3.currentProvider]\n *        The Web3 provider to use for blockchain communication. Defaults to `web3.currentProvider`\n *        if web3 is injected, otherwise will fallback to wss://rinkeby.eth.aragon.network/ws\n */\nexport default class Aragon {\n  constructor (daoAddress, options = {}) {\n    const defaultOptions = {\n      defaultGasPriceFn: () => {},\n      provider: detectProvider(),\n      cache: {\n        forceLocalStorage: false,\n        prefix: null\n      },\n      events: {\n        subscriptionDelayTime: 0\n      }\n    }\n    options = Object.assign(defaultOptions, options)\n\n    // Set up desired configuration\n    setConfiguration(\n      configurationKeys.FORCE_LOCAL_STORAGE,\n      !!(options.cache && options.cache.forceLocalStorage)\n    )\n    setConfiguration(\n      configurationKeys.SUBSCRIPTION_EVENT_DELAY,\n      Number.isFinite(options.events && options.events.subscriptionEventDelay)\n        ? options.events.subscriptionEventDelay\n        : 0\n    )\n\n    // Set up Web3\n    this.web3 = new Web3(options.provider)\n\n    // Set up ENS\n    this.ens = ens(options.provider, options.apm.ensRegistryAddress)\n\n    // Set up APM utilities\n    const { ipfs: apmIpfsOptions = {} } = options.apm\n    this.apm = apm(\n      this.web3,\n      {\n        fetchTimeout: apmIpfsOptions.fetchTimeout,\n        ipfsGateway: apmIpfsOptions.gateway\n      }\n    )\n\n    // Set up the kernel proxy\n    this.kernelProxy = makeProxy(daoAddress, 'Kernel', this.web3)\n\n    // Set up cache\n    const cachePrefix = options.cache.prefix ? `${options.cache.prefix}:${daoAddress}` : daoAddress\n    this.cache = new Cache(cachePrefix)\n\n    // Set up app contexts\n    this.appContextPool = new AppContextPool()\n\n    this.defaultGasPriceFn = options.defaultGasPriceFn\n  }\n\n  /**\n   * Initialise the wrapper.\n   *\n   * @param {Object} [options] Options\n   * @param {Object} [options.accounts] `initAccount()` options (see below)\n   * @param {Object} [options.acl] `initACL()` options (see below)\n   * @param {Object} [options.guiStyle] `initGuiStyle()` options (see below)\n   * @return {Promise<void>}\n   * @throws {Error} Will throw an error if the `daoAddress` is detected to not be a Kernel instance\n   */\n  async init (options = {}) {\n    let aclAddress\n\n    try {\n      // Check if address is kernel\n      // web3 throws if it's an empty address ('0x')\n      aclAddress = await this.kernelProxy.call('acl')\n    } catch (_) {\n      throw Error(`Provided daoAddress is not a DAO`)\n    }\n\n    await this.cache.init()\n    await this.kernelProxy.updateInitializationBlock()\n    await this.initAccounts(options.accounts)\n    await this.initAcl(Object.assign({ aclAddress }, options.acl))\n    await this.initIdentityProviders()\n    this.initApps()\n    this.initForwarders()\n    this.initAppIdentifiers()\n    this.initNetwork(options.network)\n    this.initGuiStyle(options.guiStyle)\n    this.pathIntents = new Subject()\n    this.transactions = new Subject()\n    this.signatures = new Subject()\n  }\n\n  /**\n   * Initialise the accounts observable.\n   *\n   * @param {Object} [options] Options\n   * @param {boolean} [options.fetchFromWeb3] Whether or not accounts should also be fetched from\n   *                                          the provided Web3 instance\n   * @param {Array<string>} [options.providedAccounts] Array of accounts that the user controls\n   * @return {Promise<void>}\n   */\n  async initAccounts ({ fetchFromWeb3, providedAccounts = [] } = {}) {\n    this.accounts = new ReplaySubject(1)\n    const accounts = fetchFromWeb3\n      ? providedAccounts.concat(await this.web3.eth.getAccounts())\n      : providedAccounts\n\n    this.setAccounts(accounts)\n  }\n\n  /**\n   * Initialise the ACL (Access Control List).\n   *\n   * @return {Promise<void>}\n   */\n  async initAcl ({ aclAddress } = {}) {\n    if (!aclAddress) {\n      aclAddress = await this.kernelProxy.call('acl')\n    }\n\n    // Set up ACL proxy\n    this.aclProxy = makeProxy(aclAddress, 'ACL', this.web3, { initializationBlock: this.kernelProxy.initializationBlock })\n\n    const SET_PERMISSION_EVENT = 'SetPermission'\n    const CHANGE_PERMISSION_MANAGER_EVENT = 'ChangePermissionManager'\n\n    const ACL_CACHE_KEY = getCacheKey(aclAddress, 'acl')\n\n    const REORG_SAFETY_BLOCK_AGE = 100\n\n    const currentBlock = await this.web3.eth.getBlockNumber()\n    const cacheBlockHeight = Math.max(currentBlock - REORG_SAFETY_BLOCK_AGE, 0) // clamp to 0 for safety\n\n    // Check if we have cached ACL for this address\n    // Cache object for an ACL: { permissions, blockNumber }\n    const cachedAclState = await this.cache.get(ACL_CACHE_KEY, {})\n    const { permissions: cachedPermissions, blockNumber: cachedBlockNumber } = cachedAclState\n\n    const pastEventsOptions = {\n      toBlock: cacheBlockHeight,\n      // When using cache, fetch events from the next block after cache\n      fromBlock: cachedPermissions ? cachedBlockNumber + 1 : undefined\n    }\n    const pastEvents$ = this.aclProxy.pastEvents(null, pastEventsOptions).pipe(\n      mergeMap((pastEvents) => from(pastEvents)),\n      // Custom cache event\n      endWith({\n        event: ACL_CACHE_KEY,\n        returnValues: {}\n      })\n    )\n    const currentEvents$ = this.aclProxy.events(null, { fromBlock: cacheBlockHeight + 1 }).pipe(\n      startWith({\n        event: 'starting current events',\n        returnValues: {}\n      })\n    )\n\n    // Permissions Object:\n    // { app -> role -> { manager, allowedEntities -> [ entities with permission ] } }\n    const fetchedPermissions$ = concat(pastEvents$, currentEvents$).pipe(\n      scan(([permissions], event) => {\n        const eventData = event.returnValues\n\n        if (eventData.app) {\n          // NOTE: dotprop.get() doesn't work through proxies, so we manually access permissions\n          const appPermissions = permissions[eventData.app] || {}\n\n          if (event.event === SET_PERMISSION_EVENT) {\n            const key = `${eventData.role}.allowedEntities`\n\n            // Converts to and from a set to avoid duplicated entities\n            const allowedEntitiesSet = new Set(dotprop.get(appPermissions, key, []))\n\n            if (eventData.allowed) {\n              allowedEntitiesSet.add(eventData.entity)\n            } else {\n              allowedEntitiesSet.delete(eventData.entity)\n            }\n\n            dotprop.set(appPermissions, key, Array.from(allowedEntitiesSet))\n          }\n\n          if (event.event === CHANGE_PERMISSION_MANAGER_EVENT) {\n            // We only care about the last one. An app permission can have only one manager\n            dotprop.set(appPermissions, `${eventData.role}.manager`, eventData.manager)\n          }\n\n          permissions[eventData.app] = appPermissions\n        }\n\n        return [permissions, event]\n      }, [ makeAddressMapProxy(cachedPermissions || {}) ]),\n\n      // Cache if we're finished syncing up to cache block height\n      map(([permissions, event]) => {\n        if (event.event === ACL_CACHE_KEY) {\n          this.cache.set(\n            ACL_CACHE_KEY,\n            // Make copy for cache\n            { permissions: Object.assign({}, permissions), blockNumber: cacheBlockHeight }\n          )\n        }\n        return permissions\n      }),\n\n      // Throttle so it only continues after 30ms without new values\n      // Avoids DDOSing subscribers as during initialization there may be\n      // hundreds of events processed in a short timespan\n      debounceTime(30),\n      publishReplay(1)\n    )\n    fetchedPermissions$.connect()\n\n    const cachedPermissions$ = cachedPermissions ? of(makeAddressMapProxy(cachedPermissions)) : of()\n    this.permissions = concat(cachedPermissions$, fetchedPermissions$).pipe(publishReplay(1))\n    this.permissions.connect()\n  }\n\n  /**\n   * Check if an object is an app.\n   *\n   * @param  {Object}  app\n   * @return {boolean}\n   */\n  isApp (app) {\n    return app.kernelAddress && this.isKernelAddress(app.kernelAddress)\n  }\n\n  /**\n   * Check if an address is this DAO's kernel.\n   *\n   * @param  {string}  address\n   * @return {boolean}\n   */\n  isKernelAddress (address) {\n    return addressesEqual(address, this.kernelProxy.address)\n  }\n\n  /**\n   * Initialize apps observable.\n   *\n   * @return {void}\n   */\n  initApps () {\n    /******************************\n     *                            *\n     *          CACHING           *\n     *                            *\n     ******************************/\n\n    const applicationInfoCache = new AsyncRequestCache(async (cacheKey) => {\n      const [appId, codeAddress] = cacheKey.split('.')\n      return getAragonOsInternalAppInfo(appId) ||\n        getApmInternalAppInfo(appId) ||\n        this.apm.fetchLatestRepoContentForContract(\n          await this.ens.resolve(appId),\n          codeAddress\n        )\n    })\n\n    const proxyContractValueCache = new AsyncRequestCache((proxyAddress) => {\n      if (this.isKernelAddress(proxyAddress)) {\n        const kernelProxy = makeProxy(proxyAddress, 'ERCProxy', this.web3)\n\n        return Promise.all([\n          // Use Kernel ABI\n          this.kernelProxy.call('KERNEL_APP_ID'),\n          // Use ERC897 proxy ABI\n          // Note that this won't work on old Aragon Core 0.5 Kernels,\n          // as they had not implemented ERC897 yet\n          kernelProxy.call('implementation')\n        ]).then((values) => ({\n          appId: values[0],\n          codeAddress: values[1]\n        }))\n      }\n\n      const appProxy = makeProxy(proxyAddress, 'AppProxy', this.web3)\n      const appProxyForwarder = makeProxy(proxyAddress, 'Forwarder', this.web3)\n\n      return Promise.all([\n        appProxy.call('kernel'),\n        appProxy.call('appId'),\n        appProxy.call('implementation'),\n        // Not all apps implement the forwarding interface\n        appProxyForwarder.call('isForwarder').catch(() => false)\n      ]).then((values) => ({\n        kernelAddress: values[0],\n        appId: values[1],\n        codeAddress: values[2],\n        isForwarder: values[3]\n      }))\n    })\n\n    /******************************\n     *                            *\n     *            APPS            *\n     *                            *\n     ******************************/\n\n    // Get all installed app proxy addresses\n    const installedApps$ = this.permissions.pipe(\n      map(Object.keys),\n      // Dedupe until apps change\n      distinctUntilChanged((oldProxies, newProxies) => {\n        if (oldProxies.length !== newProxies.length) {\n          return false\n        }\n        const oldSet = new Set(oldProxies)\n        const intersection = new Set(newProxies.filter(newProxy => oldSet.has(newProxy)))\n        return intersection.size === oldSet.size\n      }),\n      // Add Kernel as the first \"app\"\n      map((proxyAddresses) => {\n        const appsWithoutKernel = proxyAddresses.filter((address) => !this.isKernelAddress(address))\n        return [this.kernelProxy.address].concat(appsWithoutKernel)\n      }),\n      // Get proxy values\n      // Note that we can safely discard throttled values,\n      // so we use a `switchMap()` instead of a `mergeMap()`\n      switchMap(\n        (proxyAddresses) => Promise.all(\n          proxyAddresses.map(async (proxyAddress) => {\n            let proxyValues\n            try {\n              proxyValues = await proxyContractValueCache.request(proxyAddress)\n            } catch (_) {}\n\n            return {\n              proxyAddress,\n              ...proxyValues\n            }\n          })\n        )\n      ),\n      // Filter to remove any non-apps assigned in permissions\n      map(appProxies => appProxies.filter(\n        (appProxy) => this.isApp(appProxy) || this.isKernelAddress(appProxy.proxyAddress)\n      ))\n    )\n\n    // SetApp events are emitted when apps are installed and upgraded\n    // These may modify the implementation addresses of the proxies (modifying their behaviour), so\n    // we invalidate any caching we've done\n    const updatedApps$ = this.kernelProxy\n      // Only need to subscribe from latest block\n      .events('SetApp', { fromBlock: 'latest' })\n      .pipe(\n        // Only care about changes if they're in the APP_BASE namespace\n        filter(({ returnValues }) => isKernelAppCodeNamespace(returnValues.namespace)),\n\n        // Merge with latest value of installedApps$ so we can return the full list of apps\n        withLatestFrom(\n          installedApps$,\n          function updateApps (setAppEvent, apps) {\n            const { appId: setAppId } = setAppEvent.returnValues\n            return apps.map(async (app) => {\n              if (app.appId !== setAppId) {\n                return app\n              }\n\n              let proxyValues\n              try {\n                proxyValues = await proxyContractValueCache.request(\n                  app.proxyAddress,\n                  true // force cache invalidation\n                )\n              } catch (_) {}\n\n              return {\n                ...app,\n                ...proxyValues,\n                updated: true\n              }\n            })\n          }\n        ),\n        // Emit resolved array of promises, one at a time\n        concatMap(updatedApps => Promise.all(updatedApps))\n      )\n\n    // We merge these two observables, which both return the full list of apps attached with their\n    // proxy values:\n    //   - installedApps$: emits any time the list of installed apps changes\n    //   - updatedApps$:   emits any time SetApp could modify an installed app\n    const apps$ = merge(installedApps$, updatedApps$)\n\n    // Get artifact info for apps\n    const appsWithInfo$ = apps$.pipe(\n      concatMap(\n        (apps) => Promise.all(\n          apps.map(async (app) => {\n            let appInfo\n            if (app.appId && app.codeAddress) {\n              const cacheKey = `${app.appId}.${app.codeAddress}`\n              try {\n                appInfo = await applicationInfoCache.request(cacheKey)\n              } catch (_) { }\n            }\n\n            // This is a hack to fix web3.js and ethers not being able to detect reverts on decoding\n            // `eth_call`s (apps that implement fallbacks may revert if they haven't defined\n            // `isForwarder()`)\n            // Ideally web3.js would throw an error if it receives a revert from an `eth_call`, but\n            // as of v1.2.1, it interprets reverts as `true` :(.\n            //\n            // We check if the app's ABI actually has `isForwarder()` declared, and if not, override\n            // the isForwarder setting to false.\n            let isForwarderOverride = {}\n            if (\n              app.isForwarder &&\n              appInfo &&\n              Array.isArray(appInfo.abi) &&\n              !appInfo.abi.some(({ type, name }) => type === 'function' && name === 'isForwarder')\n            ) {\n              isForwarderOverride = {\n                isForwarder: false\n              }\n            }\n\n            return {\n              ...appInfo,\n              // Override the fetched appInfo with the actual app proxy's values to avoid mismatches\n              ...app,\n              // isForwarder override (see above)\n              ...isForwarderOverride\n            }\n          })\n        )\n      )\n    )\n\n    this.apps = appsWithInfo$.pipe(\n      publishReplay(1)\n    )\n    this.apps.connect()\n\n    /*******************************\n     *                             *\n     *            REPOS            *\n     *                             *\n     ******************************/\n\n    // Initialize installed repos from the list of apps\n    const installedRepoCache = new Map()\n    const repo$ = apps$.pipe(\n      // Map installed apps into a deduped list of their aragonPM repos, with these assumptions:\n      //   - No apps are lying about their appId (malicious apps _could_ masquerade as other\n      //     apps by setting this value themselves)\n      //   - `contractAddress`s will stay the same across all installed apps.\n      //     This is technically not true as apps could set this value themselves\n      //     (e.g. as pinned apps do), but these apps wouldn't be able to upgrade anyway\n      //\n      //  Ultimately returns an array of objects, holding the repo's:\n      //    - appId\n      //    - base contractAddress\n      map((apps) => Object.values(\n        apps\n          .filter(({ appId }) => !isAragonOsInternalApp(appId))\n          .reduce((installedRepos, { appId, codeAddress, updated }) => {\n            installedRepos[appId] = {\n              appId,\n              updated,\n              contractAddress: codeAddress\n            }\n            return installedRepos\n          }, {})\n      )),\n\n      // Filter list of installed repos into:\n      //   - New repos we haven't seen before (to begin subscribing to their version events)\n      //   - Repos we've seen before, to trigger a recalculation of the currently installed version\n      map((repos) => {\n        const newRepoAppIds = []\n        const updatedRepoAppIds = []\n\n        repos.forEach((repo) => {\n          const { appId, updated } = repo\n          if (!installedRepoCache.has(appId)) {\n            newRepoAppIds.push(appId)\n          } else if (updated) {\n            updatedRepoAppIds.push(appId)\n          }\n\n          // Mark repo as seen and cache installed information\n          installedRepoCache.set(appId, repo)\n        })\n\n        return [newRepoAppIds, updatedRepoAppIds]\n      }),\n\n      // Stop if there's no new repos or updated apps\n      filter(([newRepoAppIds, updatedRepoAppIds]) =>\n        newRepoAppIds.length || updatedRepoAppIds.length\n      ),\n\n      // Project new repos into their ids and web3 proxy objects\n      concatMap(async ([newRepoAppIds, updatedRepoAppIds]) => {\n        const newRepos = (await Promise.all(\n          newRepoAppIds.map(async (appId) => {\n            let repoProxy\n\n            try {\n              const repoAddress = await this.ens.resolve(appId)\n              repoProxy = makeRepoProxy(repoAddress, this.web3)\n              await repoProxy.updateInitializationBlock()\n            } catch (err) {\n              console.error(`Could not find repo for ${appId}`, err)\n            }\n\n            return {\n              appId,\n              repoProxy\n            }\n          })\n        ))\n          // Filter out repos we couldn't create proxies for (they were likely due to publishing\n          // invalid aragonPM repos)\n          // Note that we don't need to worry about doing this for the updated repos list; if\n          // we could not create the original repo proxy when we first saw the repo, the updates\n          // won't do anything because we weren't able to fetch enough information (versions list)\n          .filter((newRepos) => newRepos.repoProxy)\n        return [newRepos, updatedRepoAppIds]\n      }),\n\n      // Here's where the fun begins!\n      // It'll be easy to get lost, so remember to take it slowly.\n      // Just remember, with this `mergeMap()`, we'll be subscribing to all the projected (returned)\n      // observables and merging their respective emissions into a single observable.\n      //\n      // The output of this merged observable are update events containing the following:\n      //   - `appId`: mandatory, signifies which repo was updated\n      //   - `repoAddress`: optional, address of the repo contract itself\n      //   - `versions`: optional, new version information\n      mergeMap(([newRepos, updatedRepoAppIds]) => {\n        // Create a new observable to project each new update as its own update emission.\n        const update$ = of(...updatedRepoAppIds).pipe(\n          map((appId) => ({ appId }))\n        )\n\n        // Create a new observable to project each new repo as its own emission.\n        const newRepo$ = of(...newRepos)\n\n        // Create a new observable to project each new repo's address as its own update emission.\n        const repoAddress$ = newRepo$.pipe(\n          map(({ appId, repoProxy }) => ({\n            appId,\n            repoAddress: repoProxy.address\n          }))\n        )\n\n        // Create a new observable that projects each NewVersion event as its own update event\n        // emission.\n        // This one is a bit trickier, due to the higher order observable. Keep reading.\n        const version$ = newRepo$.pipe(\n          // `mergeMap()` to \"flatten\" the async transformation. This async function returns an\n          // observable, which is ultimately the NewVersion stream. More on this, after the break.\n          // Note: we don't care about the ordering, so we use `mergeMap()` instead of `concatMap()`\n          mergeMap(async ({ appId, repoProxy }) => {\n            const initialVersions = [\n              // Immediately query state from the repo contract, to avoid having to wait until all\n              // past events sync (may be long)\n              ...await getAllRepoVersions(repoProxy)\n            ]\n\n            // Return an observable subscribed to NewVersion events, giving us:\n            //   - Timestamps for versions that were published prior to this process running\n            //   - Notifications for newly published versions\n            //\n            // Reduce this with the cached version information to emit version updates for the repo.\n            return repoProxy.events('NewVersion').pipe(\n              // Project each event to a new version info object, one at a time\n              concatMap(async (event) => {\n                const { versionId: eventVersionId } = event.returnValues\n\n                // Adjust from Ethereum time\n                const timestamp = (await this.web3.eth.getBlock(event.blockNumber)).timestamp * 1000\n\n                const versionIndex = initialVersions.findIndex(({ versionId }) => versionId === eventVersionId)\n                const versionInfo =\n                  versionIndex === -1\n                    ? await getRepoVersionById(repoProxy, eventVersionId)\n                    : initialVersions[versionIndex]\n\n                return {\n                  ...versionInfo,\n                  timestamp\n                }\n              }),\n\n              // Trick to immediately emit (e.g. similar to a do/while loop)\n              startWith(null),\n\n              // Reduce newly emitted versions into the full list of versions\n              scan(({ appId, versions }, newVersionInfo) => {\n                let newVersions = versions\n                if (newVersionInfo) {\n                  const versionIndex = versions.findIndex(({ versionId }) => versionId === newVersionInfo.versionId)\n\n                  if (versionIndex === -1) {\n                    newVersions = versions.concat(newVersionInfo)\n                  } else {\n                    newVersions = Array.from(versions)\n                    newVersions[versionIndex] = newVersionInfo\n                  }\n                }\n\n                return {\n                  appId,\n                  versions: newVersions\n                }\n              }, {\n                appId,\n                versions: initialVersions\n              })\n            )\n          }),\n\n          // This bit is interesting.\n          // We've \"flattened\" our async transformation with the `mergeMap()` above, but it still\n          // returns an observable. We need to flatten this observable's emissions into the upper\n          // stream, which is what `mergeAll()` achieves.\n          mergeAll()\n        )\n\n        // Merge all of the repo update events resulting from the apps being updated, and return it\n        // to the upper `mergeMap()` so it can be re-flattened into a single event stream.\n        return merge(repoAddress$, version$, update$)\n      }),\n\n      // Reduce the event stream into a current representation of the installed repos, and which\n      // repo to update next.\n      scan(({ repos }, repoUpdate) => {\n        const { appId: updatedAppId, ...update } = repoUpdate\n        const updatedRepoInfo = {\n          ...repos[updatedAppId],\n          ...update\n        }\n\n        return {\n          repos: {\n            ...repos,\n            [updatedAppId]: updatedRepoInfo\n          },\n          updatedRepoAppId: updatedAppId\n        }\n      }, {\n        repos: {},\n        updatedRepoAppId: null\n      }),\n\n      // Stop if we don't have enough information yet to continue\n      filter(({ repos, updatedRepoAppId }) =>\n        !!updatedRepoAppId && Array.isArray(repos[updatedRepoAppId].versions)\n      ),\n\n      // Grab the full information of the updated repo using its latest values.\n      // With this, we've taken the basic stream of updates for events and mapped them onto their\n      // full repo objects.\n      concatMap(async ({ repos, updatedRepoAppId: appId }) => {\n        const { repoAddress, versions } = repos[appId]\n        const installedRepoInfo = installedRepoCache.get(appId)\n\n        const baseRepoInfo = { appId, repoAddress, versions }\n        const fetchVersionInfo = version => {\n          return applicationInfoCache\n            .request(`${appId}.${version.contractAddress}`)\n            .catch(() => ({}))\n            .then(content => ({\n              content,\n              version: version.version\n            }))\n        }\n\n        const latestVersion = versions[versions.length - 1]\n        const currentVersion = Array.from(versions)\n          // Apply reverse to find the latest version with the currently installed contract address\n          .reverse()\n          .find(version => addressesEqual(version.contractAddress, installedRepoInfo.contractAddress))\n\n        if (!currentVersion) {\n          // The organization has installed an unpublished version of this app\n          // Avoid returning a current version as we don't know what version they're using\n          return {\n            ...baseRepoInfo,\n            currentVersion: null,\n            latestVersion: await fetchVersionInfo(latestVersion)\n          }\n        }\n\n        const currentVersionInfoRequest = fetchVersionInfo(currentVersion)\n        const latestVersionInfoRequest =\n          addressesEqual(currentVersion.contractAddress, latestVersion.contractAddress)\n            ? currentVersionInfoRequest\n            : fetchVersionInfo(latestVersion)\n\n        return {\n          ...baseRepoInfo,\n          currentVersion: await currentVersionInfoRequest,\n          latestVersion: await latestVersionInfoRequest\n        }\n      })\n    )\n\n    this.installedRepos = repo$.pipe(\n      // Finally, we reduce the merged updates from individual repos into one final, expanding array\n      // of the installed repos\n      scan((repos, updatedRepo) => {\n        const repoIndex = repos.findIndex(repo => repo.repoAddress === updatedRepo.repoAddress)\n        if (repoIndex === -1) {\n          return repos.concat(updatedRepo)\n        } else {\n          const nextRepos = Array.from(repos)\n          nextRepos[repoIndex] = updatedRepo\n          return nextRepos\n        }\n      }, []),\n      // Throttle updates, but must keep trailing to ensure we don't drop any updates\n      throttleTime(500, asyncScheduler, { leading: false, trailing: true }),\n      publishReplay(1)\n    )\n    this.installedRepos.connect()\n  }\n\n  /**\n   * Initialise forwarder observable.\n   *\n   * @return {void}\n   */\n  initForwarders () {\n    this.forwarders = this.apps.pipe(\n      map(\n        (apps) => apps.filter((app) => app.isForwarder)\n      ),\n      publishReplay(1)\n    )\n    this.forwarders.connect()\n  }\n\n  /**\n   * Initialise app identifier observable.\n   *\n   * @return {void}\n   */\n  initAppIdentifiers () {\n    this.appIdentifiers = new BehaviorSubject({}).pipe(\n      scan(\n        (identifiers, { address, identifier }) =>\n          Object.assign(identifiers, { [address]: identifier })\n      ),\n      publishReplay(1)\n    )\n    this.appIdentifiers.connect()\n  }\n\n  /**\n   * Set the identifier of an app.\n   *\n   * @param {string} address The proxy address of the app\n   * @param {string} identifier The identifier of the app\n   * @return {void}\n   */\n  setAppIdentifier (address, identifier) {\n    this.appIdentifiers.next({\n      address,\n      identifier\n    })\n  }\n\n  /**\n   * Initialise identity providers.\n   *\n   * @return {Promise<void>}\n   */\n  async initIdentityProviders () {\n    const defaultIdentityProviders = [{\n      name: 'local',\n      provider: new LocalIdentityProvider()\n    }]\n    // TODO: detect other installed providers\n    const detectedIdentityProviders = []\n    const identityProviders = [...defaultIdentityProviders, ...detectedIdentityProviders]\n\n    // Init all providers\n    await Promise.all(identityProviders.map(({ provider }) => {\n      // Most providers should have this defined to a noop function by default, but just in case\n      if (typeof provider.init === 'function') {\n        return provider.init()\n      }\n      return Promise.resolve()\n    }))\n\n    this.identityProviderRegistrar = new Map(\n      identityProviders.map(({ name, provider }) => [name, provider])\n    )\n    // Set up identity modification intent observable\n    this.identityIntents = new Subject()\n  }\n\n  /**\n   * Modify the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to modify\n   * @param  {Object} metadata Modification metadata object\n   * @return {Promise} Resolves if the modification was successful\n   */\n  modifyAddressIdentity (address, metadata) {\n    const providerName = 'local'\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.modify === 'function') {\n      return provider.modify(address, metadata)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Resolve the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  resolveAddressIdentity (address) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.resolve === 'function') {\n      return provider.resolve(address)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Search identities based on a term\n   *\n   * @param  {string} searchTerm\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  searchIdentities (searchTerm) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.search === 'function') {\n      return provider.search(searchTerm)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Request an identity modification using the highest priority provider.\n   *\n   * Returns a promise which delegates resolution to the handler\n   * which listens and handles `this.identityIntents`\n   *\n   * @param  {string} address Address to modify\n   * @return {Promise} Resolved by the handler of identityIntents\n   */\n  requestAddressIdentityModification (address) {\n    const providerName = 'local' // TODO - get provider\n    if (this.identityProviderRegistrar.has(providerName)) {\n      return new Promise((resolve, reject) => {\n        this.identityIntents.next({\n          address,\n          providerName,\n          resolve,\n          reject (err) {\n            reject(err || new Error('The identity modification was not completed'))\n          }\n        })\n      })\n    }\n\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Remove selected local identities\n   *\n   * @param {Array<string>} addresses The addresses to be removed from the local identity provider\n   * @return {Promise}\n   */\n  async removeLocalIdentities (addresses) {\n    const localProvider = this.identityProviderRegistrar.get('local')\n    for (const address of addresses) {\n      await localProvider.remove(address)\n    }\n  }\n\n  /**\n   * Get all local identities for listing functionality\n   *\n   * @return {Promise<Object>}\n   */\n  getLocalIdentities () {\n    return this.identityProviderRegistrar.get('local').getAll()\n  }\n\n  /**\n   * Initialise the GUI style observable.\n   *\n   * @param {Object} style GUI style options\n   * @param {string} style.appearance \"dark\" or \"light\"\n   * @param {Object} [style.theme] The theme object\n   * @return {void}\n   */\n  initGuiStyle ({ appearance, theme } = {}) {\n    this.guiStyle = new BehaviorSubject({\n      appearance: appearance || 'light',\n      theme: theme || null\n    })\n  }\n\n  /**\n   * Set the GUI style (theme and appearance).\n   *\n   * @param {string} appearance \"dark\" or \"light\"\n   * @param {Object} [theme] The theme object.\n   * @return {void}\n   */\n  setGuiStyle (appearance, theme = null) {\n    this.guiStyle.next({\n      appearance,\n      theme\n    })\n  }\n\n  /**\n   * Initialise the network observable.\n   *\n   * @param {Object} network information of node\n   * @return {Promise<void>}\n   */\n  async initNetwork (network) {\n    this.network = new ReplaySubject(1)\n\n    if (network) {\n      this.network.next(network)\n    } else {\n      this.network.next({\n        id: await this.web3.eth.getChainId(),\n        type: await this.web3.eth.net.getNetworkType()\n      })\n    }\n  }\n\n  /**\n   * Request an app's path be changed.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {Promise} Succeeds if path request was allowed\n   */\n  async requestAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    if (!await this.getApp(appAddress)) {\n      throw new Error(`Cannot request path for non-installed app: ${appAddress}`)\n    }\n\n    return new Promise((resolve, reject) => {\n      this.pathIntents.next({\n        appAddress,\n        path,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The path was rejected'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Set an app's path.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {void}\n   */\n  setAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    this.appContextPool.emit(appAddress, APP_CONTEXTS.PATH, path)\n  }\n\n  /**\n   * Run an app.\n   *\n   * As there may be race conditions with losing messages from cross-context environments,\n   * running an app is split up into two parts:\n   *\n   *   1. Set up any required state for the app. This step is allowed to be asynchronous.\n   *   2. Connect the app to a running context, by associating the context's message provider\n   *      to the app. This step is synchronous.\n   *\n   * @param  {string} proxyAddress\n   *         The address of the app proxy.\n   * @return {Promise<function>}\n   */\n  async runApp (proxyAddress) {\n    // Step 1: Set up required state for the app\n\n    // Only get the first result from the observable, so our running contexts don't get\n    // reinitialized if new apps appear\n    const apps = await this.apps.pipe(first()).toPromise()\n\n    const app = apps.find((app) => addressesEqual(app.proxyAddress, proxyAddress))\n\n    // TODO: handle undefined (no proxy found), otherwise when calling app.proxyAddress next, it will throw\n    const appProxy = makeProxyFromAppABI(app.proxyAddress, app.abi, this.web3)\n\n    await appProxy.updateInitializationBlock()\n\n    // Step 2: Associate app with running context\n    return (sandboxMessengerProvider) => {\n      // Set up messenger\n      const messenger = new Messenger(\n        sandboxMessengerProvider\n      )\n\n      // Wrap requests with the application proxy\n      // Note that we have to do this synchronously with the creation of the message provider,\n      // as we otherwise risk race conditions and may lose messages\n      const request$ = messenger.requests().pipe(\n        map(request => ({ request, proxy: appProxy, wrapper: this })),\n        // Use the same request$ result in each handler\n        // Turns request$ into a subject\n        publishReplay(1)\n      )\n      request$.connect()\n\n      // Register request handlers\n      const handlerSubscription = handlers.combineRequestHandlers(\n        // Generic handlers\n        handlers.createRequestHandler(request$, 'accounts', handlers.accounts),\n        handlers.createRequestHandler(request$, 'cache', handlers.cache),\n        handlers.createRequestHandler(request$, 'describe_script', handlers.describeScript),\n        handlers.createRequestHandler(request$, 'describe_transaction', handlers.describeTransaction),\n        handlers.createRequestHandler(request$, 'get_apps', handlers.getApps),\n        handlers.createRequestHandler(request$, 'network', handlers.network),\n        handlers.createRequestHandler(request$, 'path', handlers.path),\n        handlers.createRequestHandler(request$, 'gui_style', handlers.guiStyle),\n        handlers.createRequestHandler(request$, 'trigger', handlers.trigger),\n        handlers.createRequestHandler(request$, 'web3_eth', handlers.web3Eth),\n\n        // Contract handlers\n        handlers.createRequestHandler(request$, 'intent', handlers.intent),\n        handlers.createRequestHandler(request$, 'call', handlers.call),\n        handlers.createRequestHandler(request$, 'sign_message', handlers.signMessage),\n        handlers.createRequestHandler(request$, 'events', handlers.events),\n        handlers.createRequestHandler(request$, 'past_events', handlers.pastEvents),\n\n        // External contract handlers\n        handlers.createRequestHandler(request$, 'external_call', handlers.externalCall),\n        handlers.createRequestHandler(request$, 'external_events', handlers.externalEvents),\n        handlers.createRequestHandler(request$, 'external_intent', handlers.externalIntent),\n        handlers.createRequestHandler(request$, 'external_past_events', handlers.externalPastEvents),\n\n        // Identity handlers\n        handlers.createRequestHandler(request$, 'identify', handlers.appIdentifier),\n        handlers.createRequestHandler(request$, 'address_identity', handlers.addressIdentity),\n        handlers.createRequestHandler(request$, 'search_identities', handlers.searchIdentities)\n      ).subscribe(\n        (response) => messenger.sendResponse(response.id, response.payload)\n      )\n\n      // The attached unsubscribe isn't automatically bound to the subscription\n      const shutdown = () => handlerSubscription.unsubscribe()\n\n      const shutdownAndClearCache = async () => {\n        shutdown()\n\n        // Remove all cache keys related to this app one by one\n        return Object\n          .keys(await this.cache.getAll())\n          .reduce((promise, cacheKey) => {\n            return promise.then(() =>\n              cacheKey.startsWith(proxyAddress)\n                ? this.cache.remove(cacheKey)\n                : Promise.resolve()\n            )\n          }, Promise.resolve())\n      }\n\n      return {\n        shutdown,\n        shutdownAndClearCache\n      }\n    }\n  }\n\n  /**\n   * Set the available accounts for the current user.\n   *\n   * @param {Array<string>} accounts\n   * @return {void}\n   */\n  setAccounts (accounts) {\n    this.accounts.next(accounts)\n  }\n\n  /**\n   * Get the available accounts for the current user.\n   *\n   * @return {Promise<Array<string>>} An array of addresses\n   */\n  getAccounts () {\n    return this.accounts.pipe(first()).toPromise()\n  }\n\n  /**\n   * Allows apps to sign arbitrary data via a RPC call\n   *\n   * @param {string} message to be signed\n   * @param {string} requestingApp proxy address of requesting app\n   * @return {Promise<string>} signature hash\n   */\n  signMessage (message, requestingApp) {\n    if (typeof message !== 'string') {\n      return Promise.reject(new Error('Message to sign must be a string'))\n    }\n    return new Promise((resolve, reject) => {\n      this.signatures.next({\n        message,\n        requestingApp,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The message was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * @param {Array<Object>} transactionPath An array of Ethereum transactions that describe each\n   *   step in the path\n   * @param {Object} [options]\n   * @param {boolean} [options.external] Whether the transaction path is initiating an action on\n   *   an external destination (not the currently running app)\n   * @return {Promise<string>} Promise that should be resolved with the sent transaction hash\n   */\n  performTransactionPath (transactionPath, { external } = {}) {\n    return new Promise((resolve, reject) => {\n      this.transactions.next({\n        resolve,\n        external: !!external,\n        transaction: transactionPath[0],\n        path: transactionPath,\n        reject (err) {\n          reject(err || new Error('The transaction was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Performs an action on the ACL using transaction pathing\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<string>} transaction hash\n   */\n  async performACLIntent (method, params) {\n    const path = await this.getACLTransactionPath(method, params)\n    return this.performTransactionPath(path)\n  }\n\n  /**\n   * Looks for app with the provided proxyAddress and returns its app object if found\n   *\n   * @param {string} proxyAddress\n   * @return {Promise<Object>} The app object\n   */\n  getApp (proxyAddress) {\n    return this.apps.pipe(\n      map(apps => apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))),\n      first()\n    ).toPromise()\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getTransactionPath (destination, methodSignature, params, finalForwarder) {\n    const accounts = await this.getAccounts()\n\n    for (let account of accounts) {\n      const path = await this.calculateTransactionPath(\n        account,\n        destination,\n        methodSignature,\n        params,\n        finalForwarder\n      )\n\n      if (path.length > 0) {\n        try {\n          return this.describeTransactionPath(path)\n        } catch (_) {\n          return path\n        }\n      }\n    }\n\n    return []\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to an external `destination`\n   * (not the currently running app) that invokes a method matching the\n   * `methodAbiFragment` with `params`.\n   *\n   * @param  {string} destination Address of the external contract\n   * @param  {object} methodAbiFragment ABI fragment of method to invoke\n   * @param  {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path.\n   *   If the destination is a non-installed contract, always results in an array containing a\n   *   single transaction.\n   */\n  async getExternalTransactionPath (destination, methodAbiFragment, params) {\n    if (addressesEqual(destination, this.aclProxy.address)) {\n      try {\n        return this.getACLTransactionPath(methodAbiFragment.name, params)\n      } catch (_) {\n        return []\n      }\n    }\n\n    const installedApp = await this.getApp(destination)\n    if (installedApp) {\n      // Destination is an installed app; need to go through normal transaction pathing\n      return this.getTransactionPath(destination, methodAbiFragment.name, params)\n    }\n\n    // Destination is not an installed app on this org, just create a direct transaction\n    // with the first account\n    const account = (await this.getAccounts())[0]\n\n    try {\n      const tx = await createDirectTransaction(account, destination, methodAbiFragment, params, this.web3)\n      return this.describeTransactionPath([tx])\n    } catch (_) {\n      return []\n    }\n  }\n\n  /**\n   * Calculate the transaction path for a basket of intents.\n   * Expects the `intentBasket` to be an array of tuples holding the following:\n   *   {string}   destination: destination address\n   *   {string}   methodSignature: method to invoke on destination\n   *   {Array<*>} params: method params\n   * These are the same parameters as the ones used for `getTransactionPath()`\n   *\n   * Allows user to specify how many of the intents should be checked to ensure their paths are\n   * compatible. `checkMode` supports:\n   *   'all': All intents will be checked to make sure they use the same forwarding path.\n   *   'single': assumes all intents can use the path found from the first intent\n   *\n   * @param  {Array<Array<string, string, Array<*>>>} intentBasket Intents\n   * @param  {Object} [options]\n   * @param  {string} [options.checkMode] Path checking mode\n   * @return {Promise<Object>} An object containing:\n   *   - `path` (Array<Object>): a multi-step transaction path that eventually invokes this basket.\n   *     Empty if no such path could be found.\n   *   - `transactions` (Array<Object>): array of Ethereum transactions that invokes this basket.\n   *     If a multi-step transaction path was found, returns the first transaction in that path.\n   *     Empty if no such transactions could be found.\n   */\n  async getTransactionPathForIntentBasket (intentBasket, { checkMode = 'all' } = {}) {\n    // Get transaction paths for entire basket\n    const intentsToCheck =\n      checkMode === 'all'\n        ? intentBasket // all -- use all intents\n        : checkMode === 'single'\n          ? [intentBasket[0]] // single -- only use first intent\n          : []\n    const intentPaths = await Promise.all(\n      intentsToCheck.map(\n        ([destination, methodSignature, params]) =>\n          addressesEqual(destination, this.aclProxy.address)\n            ? this.getACLTransactionPath(methodSignature, params)\n            : this.getTransactionPath(destination, methodSignature, params)\n      )\n    )\n\n    // If the paths don't match, we can't send the transactions in this intent basket together\n    const pathsMatch = doIntentPathsMatch(intentPaths)\n    if (pathsMatch) {\n      // Create direct transactions for each intent in the intentBasket\n      const sender = (await this.getAccounts())[0] // TODO: don't assume it's the first account\n      const directTransactions = await Promise.all(\n        intentBasket.map(\n          async ([destination, methodSignature, params]) =>\n            createDirectTransactionForApp(sender, await this.getApp(destination), methodSignature, params, this.web3)\n        )\n      )\n\n      if (intentPaths[0].length === 1) {\n        // Sender has direct access\n        try {\n          const decoratedTransactions = await this.describeTransactionPath(\n            await Promise.all(\n              directTransactions.map(transaction => this.applyTransactionGas(transaction))\n            )\n          )\n\n          return {\n            path: [],\n            transactions: decoratedTransactions\n          }\n        } catch (_) { }\n      } else {\n        // Need to encode calls scripts for each forwarder transaction in the path\n        const createForwarderTransaction = createForwarderTransactionBuilder(sender, {}, this.web3)\n        const forwarderPath = intentPaths[0]\n          // Ignore the last part of the path, which was the original intent\n          .slice(0, -1)\n          // Start from the \"last\" forwarder and move backwards to the sender\n          .reverse()\n          // Just use the forwarders' addresses\n          .map(({ to }) => to)\n          .reduce(\n            (path, nextForwarder) => {\n              const lastStep = path[0]\n              const encodedLastStep = encodeCallScript(Array.isArray(lastStep) ? lastStep : [lastStep])\n              return [createForwarderTransaction(nextForwarder, encodedLastStep), ...path]\n            },\n            // Start the recursive calls script encoding with the direct transactions for the\n            // intent basket\n            [directTransactions]\n          )\n\n        try {\n          // Put the finishing touches: apply gas, and add radspec descriptions\n          forwarderPath[0] = await this.applyTransactionGas(forwarderPath[0], true)\n          return {\n            path: await this.describeTransactionPath(forwarderPath),\n            // When we have a path, we only need to send the first transaction to start it\n            transactions: [forwarderPath[0]]\n          }\n        } catch (_) { }\n      }\n    }\n\n    // Failed to find a path\n    return {\n      path: [],\n      transactions: []\n    }\n  }\n\n  /**\n   * Get the permission manager for an `app`'s and `role`.\n   *\n   * @param {string} appAddress\n   * @param {string} roleHash\n   * @return {Promise<string>} The permission manager\n   */\n  async getPermissionManager (appAddress, roleHash) {\n    const permissions = await this.permissions.pipe(first()).toPromise()\n    const appPermissions = permissions[appAddress]\n\n    return dotprop.get(appPermissions, `${roleHash}.manager`)\n  }\n\n  /**\n   * Calculates transaction path for performing a method on the ACL\n   *\n   * @param {string} methodSignature\n   * @param {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getACLTransactionPath (methodSignature, params) {\n    const aclAddr = this.aclProxy.address\n    const acl = await this.getApp(aclAddr)\n\n    const method = findAppMethodFromSignature(acl, methodSignature, { allowDeprecated: false })\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ACL`)\n    }\n\n    if (method.roles && method.roles.length !== 0) {\n      // This action can be done with regular transaction pathing (it's protected by an ACL role)\n      return this.getTransactionPath(aclAddr, methodSignature, params)\n    } else {\n      // Some ACL functions don't have a role and are instead protected by a manager\n      // Inspect the matched method's ABI to find the position of the 'app' and 'role' parameters\n      // needed to get the permission manager\n      const methodAbiFragment = findMethodAbiFragment(acl.abi, methodSignature)\n      if (!methodAbiFragment) {\n        throw new Error(`Method ${method} not found on ACL ABI`)\n      }\n\n      const inputNames = methodAbiFragment.inputs.map((input) => input.name)\n      const appIndex = inputNames.indexOf('_app')\n      const roleIndex = inputNames.indexOf('_role')\n\n      if (appIndex === -1 || roleIndex === -1) {\n        throw new Error(`Method ${methodSignature} doesn't take _app and _role as input. Permission manager cannot be found.`)\n      }\n\n      const manager = await this.getPermissionManager(params[appIndex], params[roleIndex])\n\n      return this.getTransactionPath(aclAddr, methodSignature, params, manager)\n    }\n  }\n\n  /**\n   * Decodes an EVM callscript and returns the transaction path it describes.\n   *\n   * @param  {string} script\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  decodeTransactionPath (script) {\n    // In the future we may support more EVMScripts, but for now let's just assume we're only\n    // dealing with call scripts\n    if (!isCallScript(script)) {\n      throw new Error(`Script could not be decoded: ${script}`)\n    }\n\n    const path = decodeCallScript(script)\n    return path.map((segment) => {\n      const { data } = segment\n\n      if (isValidForwardCall(data)) {\n        const forwardedEvmScript = parseForwardCall(data)\n\n        try {\n          segment.children = this.decodeTransactionPath(forwardedEvmScript)\n        } catch (err) {}\n      }\n\n      return segment\n    })\n  }\n\n  /**\n   * Use radspec to create a human-readable description for each transaction in the given `path`\n   *\n   * @param  {Array<Object>} path\n   * @return {Promise<Array<Object>>} The given `path`, with decorated with descriptions at each step\n   */\n  async describeTransactionPath (path) {\n    return Promise.all(path.map(async (step) => {\n      let decoratedStep\n\n      if (Array.isArray(step)) {\n        // Intent basket with multiple transactions in a single callscript\n        // First see if the step can be handled with a specialized descriptor\n        try {\n          decoratedStep = await tryDescribingUpgradeOrganizationBasket(step, this)\n        } catch (err) { }\n\n        // If the step wasn't handled, just individually describe each of the transactions\n        return decoratedStep || this.describeTransactionPath(step)\n      }\n\n      // Single transaction step\n      // First see if the step can be handled with a specialized descriptor\n      try {\n        decoratedStep = await tryDescribingUpdateAppIntent(step, this)\n      } catch (err) { }\n\n      // Finally, if the step wasn't handled yet, evaluate via radspec normally\n      if (!decoratedStep) {\n        try {\n          decoratedStep = await tryEvaluatingRadspec(step, this)\n        } catch (err) { }\n      }\n\n      // Annotate the description, if one was found\n      if (decoratedStep) {\n        if (decoratedStep.description) {\n          try {\n            const processed = await postprocessRadspecDescription(decoratedStep.description, this)\n            decoratedStep.description = processed.description\n            decoratedStep.annotatedDescription = processed.annotatedDescription\n          } catch (err) { }\n        }\n\n        if (decoratedStep.children) {\n          decoratedStep.children = await this.describeTransactionPath(decoratedStep.children)\n        }\n      }\n\n      return decoratedStep || step\n    }))\n  }\n\n  /**\n   * Whether the `sender` can use the `forwarder` to invoke `script`.\n   *\n   * @param  {string} forwarder\n   * @param  {string} sender\n   * @param  {string} script\n   * @return {Promise<bool>}\n   */\n  canForward (forwarder, sender, script) {\n    const canForward = new this.web3.eth.Contract(\n      getAbi('aragon/Forwarder'),\n      forwarder\n    ).methods['canForward']\n\n    return canForward(sender, script).call().catch(() => false)\n  }\n\n  getDefaultGasPrice (gasLimit) {\n    return this.defaultGasPriceFn(gasLimit)\n  }\n\n  /**\n   * Calculates and applies the gas limit and gas price for a transaction\n   *\n   * @param  {Object} transaction\n   * @param  {bool} isForwarding\n   * @return {Promise<Object>} The transaction with the gas limit and gas price added.\n   *                           If the transaction fails from the estimateGas check, the promise will\n   *                           be rejected with the error.\n   */\n  async applyTransactionGas (transaction, isForwarding = false) {\n    // If a pretransaction is required for the main transaction to be performed,\n    // performing web3.eth.estimateGas could fail until the pretransaction is mined\n    // Example: erc20 approve (pretransaction) + deposit to vault (main transaction)\n    if (transaction.pretransaction) {\n      // Calculate gas settings for pretransaction\n      transaction.pretransaction = await this.applyTransactionGas(transaction.pretransaction, false)\n      // Note: for transactions with pretransactions gas limit and price cannot be calculated\n      return transaction\n    }\n\n    // NOTE: estimateGas mutates the argument object and transforms the address to lowercase\n    // so this is a hack to make sure checksums are not destroyed\n    // Also, at the same time it's a hack for checking if the call will revert,\n    // since `eth_call` returns `0x` if the call fails and if the call returns nothing.\n    // So yeah...\n    const estimatedGasLimit = await this.web3.eth.estimateGas({ ...transaction, gas: undefined })\n    const recommendedGasLimit = await getRecommendedGasLimit(this.web3, estimatedGasLimit)\n\n    // If the gas provided in the intent is lower than the estimated gas, use the estimation\n    // when forwarding as it requires more gas and otherwise the transaction would go out of gas\n    if (!transaction.gas || (isForwarding && transaction.gas < recommendedGasLimit)) {\n      transaction.gas = recommendedGasLimit\n    }\n\n    if (!transaction.gasPrice) {\n      transaction.gasPrice = await this.getDefaultGasPrice(transaction.gas)\n    }\n\n    return transaction\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action.\n   *                  Needed for actions that aren't in the ACL but whose execution depends on other factors\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateTransactionPath (sender, destination, methodSignature, params, finalForwarder) {\n    // Get the destination app\n    const app = await this.getApp(destination)\n    if (!app) {\n      throw new Error(`Transaction path destination (${destination}) is not an installed app`)\n    }\n\n    const method = findAppMethodFromSignature(app, methodSignature, { allowDeprecated: false })\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ${destination}`)\n    }\n\n    // Create transaction for target action\n    const directTransaction = await createDirectTransactionForApp(sender, app, methodSignature, params, this.web3)\n\n    const finalForwarderProvided = isAddress(finalForwarder)\n\n    // We can already assume the user is able to directly invoke the action if:\n    //   - The method has no ACL requirements and no final forwarder was given, or\n    //   - The final forwarder matches the sender\n    if (\n      (method.roles.length === 0 && !finalForwarderProvided) ||\n      addressesEqual(finalForwarder, sender)\n    ) {\n      try {\n        // `applyTransactionGas` can throw if the transaction will fail\n        return [await this.applyTransactionGas(directTransaction)]\n      } catch (_) {\n        // If the direct transaction fails, we give up as we should have been able to\n        // perform the action directly\n        return []\n      }\n    }\n\n    // Failing this, attempt transaction pathing algorithm with forwarders\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders.map(\n        (forwarder) => forwarder.proxyAddress\n      )\n    )\n\n    let forwardersWithPermission\n    if (finalForwarderProvided) {\n      if (!includesAddress(forwarders, finalForwarder)) {\n        // Final forwarder was given, but did not match any available forwarders, so no path\n        // could be found\n        return []\n      }\n\n      // Only attempt to find path with declared final forwarder; assume the final forwarder\n      // is able to invoke the action\n      forwardersWithPermission = [finalForwarder]\n    } else {\n      // Find entities with the required permissions\n      const permissions = await this.permissions.pipe(first()).toPromise()\n      const destinationPermissions = permissions[destination]\n      const roleSig = app.roles.find(\n        (role) => role.id === method.roles[0]\n      ).bytes\n      const allowedEntities = dotprop.get(\n        destinationPermissions,\n        `${roleSig}.allowedEntities`,\n        []\n      )\n\n      // No one has access, so of course we don't as well\n      if (allowedEntities.length === 0) {\n        return []\n      }\n\n      // User may have permission; attempt direct transaction\n      if (\n        includesAddress(allowedEntities, sender) ||\n        includesAddress(allowedEntities, ANY_ENTITY)\n      ) {\n        try {\n          // `applyTransactionGas` can throw if the transaction will fail\n          return [await this.applyTransactionGas(directTransaction)]\n        } catch (_) {\n          // Don't immediately fail as the permission could have parameters applied that\n          // disallows the user from the current action and forces us to use the full\n          // pathing algorithm\n        }\n      }\n\n      // Find forwarders with permission to perform the action\n      forwardersWithPermission = forwarders.filter(\n        (forwarder) => includesAddress(allowedEntities, forwarder)\n      )\n    }\n\n    return this.calculateForwardingPath(sender, destination, directTransaction, forwardersWithPermission)\n  }\n\n  /**\n   * Calculate the forwarding path for a transaction to `destination`\n   * that invokes `directTransaction`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {Object} directTransaction\n   * @param  {string} [forwardersWithPermission]\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateForwardingPath (sender, destination, directTransaction, forwardersWithPermission) {\n    // No forwarders can perform the requested action\n    if (forwardersWithPermission.length === 0) {\n      return []\n    }\n\n    // TODO: handle pretransactions specified in the intent\n    // This is difficult to do generically, as some pretransactions\n    // (e.g. token approvals) only work if they're for a specific target\n    delete directTransaction.pretransaction\n\n    const createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction, this.web3)\n\n    // Check if one of the forwarders that has permission to perform an action\n    // with `sig` on `address` can forward for us directly\n    for (const forwarder of forwardersWithPermission) {\n      const script = encodeCallScript([directTransaction])\n      if (await this.canForward(forwarder, sender, script)) {\n        const transaction = createForwarderTransaction(forwarder, script)\n        try {\n          const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n          // `applyTransactionGas` can throw if the transaction will fail\n          // If that happens, we give up as we should've been able to perform the action with this\n          // forwarder\n          return [await this.applyTransactionGas(transactionWithFee, true), directTransaction]\n        } catch (err) {\n          return []\n        }\n      }\n    }\n\n    // Get a list of all forwarders (excluding the forwarders with direct permission)\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders\n        .map((forwarder) => forwarder.proxyAddress)\n        .filter((forwarder) => !includesAddress(forwardersWithPermission, forwarder))\n    )\n\n    // Set up the path finding queue\n    // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n    // In other words: it is an array of tuples, where the first index of the tuple\n    // is the current path and the second index of the tuple is the\n    // queue (a list of unexplored forwarder addresses) for that path\n    const queue = forwardersWithPermission.map((forwarderWithPermission) => {\n      return [\n        [\n          createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])),\n          directTransaction\n        ], forwarders\n      ]\n    })\n\n    // Find the shortest path via a breadth-first search of forwarder paths.\n    // We do a breadth-first instead of depth-first search because:\n    //   - We assume that most forwarding paths will be quite short, so it should be faster\n    //     to check in \"stages\" rather than exhaust single paths\n    //   - We don't currently protect against cycles in the path, and so exhausting single\n    //     paths can be wasteful if they result in dead ends\n    // TODO(onbjerg): Should we find and return multiple paths?\n    do {\n      const [path, [forwarder, ...nextQueue]] = queue.shift()\n\n      // Skip if no forwarder or the path is longer than 5\n      if (!forwarder || path.length > 5) continue\n\n      // Get the previous forwarder address\n      const previousForwarder = path[0].to\n\n      // Encode the previous transaction into an EVM callscript\n      const script = encodeCallScript([path[0]])\n\n      if (await this.canForward(previousForwarder, forwarder, script)) {\n        if (await this.canForward(forwarder, sender, script)) {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // and this forwarder can forward for our address, so we have found a path\n          const transaction = createForwarderTransaction(forwarder, script)\n\n          // Only apply pretransactions and gas to the first transaction in the path\n          // as it's the only one that will be executed by the user\n          try {\n            const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n            // `applyTransactionGas` can throw if the transaction will fail\n            // If that happens, we give up as we should've been able to perform the action with this\n            // forwarding path\n            return [await this.applyTransactionGas(transactionWithFee, true), ...path]\n          } catch (err) {\n            return []\n          }\n        } else {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // but this forwarder can not forward for our address, so we add it as a\n          // possible path in the queue for later exploration.\n          queue.push([\n            [createForwarderTransaction(forwarder, script), ...path],\n            // Avoid including the current forwarder as a candidate for the next step\n            // in the path. Note that this is naive and may result in repeating cycles,\n            // but the maximum path length would prevent against infinite loops\n            forwarders.filter((nextForwarder) => nextForwarder !== forwarder)\n          ])\n        }\n      }\n\n      // We add the current path on the back of the queue again, but we shorten\n      // the list of possible forwarders.\n      queue.push([path, nextQueue])\n    } while (queue.length)\n\n    return []\n  }\n}\n\n// Re-export some web3 utilities\nexport { apm, getRecommendedGasLimit }\nexport { resolve as ensResolve } from './ens'\n\n// Re-export the AddressIdentityProvider abstract base class\nexport { AddressIdentityProvider } from './identity'\n\n// Re-export the Aragon RPC providers\nexport { providers } from '@aragon/rpc-messenger'\n"],"file":"index.js"}