{"version":3,"sources":["../../../src/core/proxy/index.js"],"names":["ContractProxy","constructor","address","jsonInterface","web3","initializationBlock","contract","eth","Contract","pastEvents","eventNames","options","fromBlock","length","Promise","resolve","ranges","i","toBlock","push","res","range","arr","getPastEvents","concat","then","events","filter","event","includes","eventSource","allEvents","pipe","eventDelay","configurationKeys","SUBSCRIPTION_EVENT_DELAY","call","method","params","methods","Error","lastParam","slice","updateInitializationBlock","initBlock","getInitializationBlock"],"mappings":"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","sourcesContent":["import { fromEvent, from } from 'rxjs'\nimport { delay, filter } from 'rxjs/operators'\nimport { getConfiguration } from '../../configuration'\nimport * as configurationKeys from '../../configuration/keys'\nimport { getEventNames } from '../../utils/events'\n\nexport default class ContractProxy {\n  constructor (address, jsonInterface, web3, { initializationBlock = 0 } = {}) {\n    this.address = address\n    this.contract = new web3.eth.Contract(\n      jsonInterface,\n      address\n    )\n    this.web3 = web3\n    this.initializationBlock = initializationBlock\n  }\n\n  /**\n   * Fetches past events for a given block range\n   *\n   * @param {Array<String>} eventNames events to fetch\n   * @param {Object} [options] web3.eth.Contract.getPastEvents()' options\n   *   The fromBlock is defaulted to this app's initializationBlock unless explicitly provided\n   * @return {Observable} Single-emission observable with an array of past events\n   */\n  pastEvents (eventNames, options = {}) {\n    options.fromBlock = options.fromBlock || this.initializationBlock\n    eventNames = getEventNames(eventNames)\n\n\n\n    // The `from`s only unpack the returned Promises (and not the array inside them!)\n    if (eventNames.length === 1) {\n      // Get a specific event or all events unfiltered\n      return from(\n        new Promise(async resolve => {\n          // console.log(\"Resolving \", resolve);\n          const ranges = [];\n\n          for (let i = +options.fromBlock; i < +options.toBlock; i += 1024) {\n            ranges.push({ ...options, fromBlock: i, toBlock: (i + 1023) > options.toBlock ? options.toBlock : i + 1023 });\n          }\n\n          // console.log(ranges);\n          // console.log(options);\n\n          let res = [];\n          for (let range of ranges) {\n            const arr = await this.contract.getPastEvents(eventNames[0], range);\n            if (arr && arr.length)\n              res = res.concat(arr);\n          }\n          // console.log(ranges, res);\n          resolve(res);\n        })\n      );\n      // return from(this.contract.getPastEvents(eventNames[0], options));\n    } else {\n      // Get all events and filter ourselves\n      return from(\n        this.contract.getPastEvents('allEvents', options)\n          .then(events => events.filter(event => eventNames.includes(event.event)))\n      )\n    }\n  }\n\n  /**\n   * Subscribe to events, fetching past events if necessary (based on the given options)\n   *\n   * @param {Array<String>} eventNames events to fetch\n   * @param {Object} options web3.eth.Contract.events()' options\n   *   The fromBlock is defaulted to this app's initializationBlock unless explicitly provided\n   * @return {Observable} Multi-emission observable with individual events\n   */\n  events (eventNames, options = {}) {\n    options.fromBlock = options.fromBlock || this.initializationBlock\n    eventNames = getEventNames(eventNames)\n\n    let eventSource\n    if (eventNames.length === 1) {\n      // Get a specific event or all events unfiltered\n      eventSource = fromEvent(\n        this.contract.events[eventNames[0]](options),\n        'data'\n      )\n    } else {\n      // Get all events and filter ourselves\n      eventSource = fromEvent(\n        this.contract.events.allEvents(options),\n        'data'\n      ).pipe(\n        filter((event) => eventNames.includes(event.event))\n      )\n    }\n\n    const eventDelay = getConfiguration(configurationKeys.SUBSCRIPTION_EVENT_DELAY) || 0\n    // Small optimization: don't pipe a delay if we don't have to\n    return eventDelay ? eventSource.pipe(delay(eventDelay)) : eventSource\n  }\n\n  async call (method, ...params) {\n    if (!this.contract.methods[method]) {\n      throw new Error(`No method named ${method} on ${this.address}`)\n    }\n\n    const lastParam = params[params.length - 1]\n\n    return (typeof lastParam === 'object' && lastParam !== null)\n      ? this.contract.methods[method](...params.slice(0, -1)).call(lastParam)\n      : this.contract.methods[method](...params).call()\n  }\n\n  async updateInitializationBlock () {\n    const initBlock = await this.contract.methods.getInitializationBlock().call()\n    this.initializationBlock = initBlock\n  }\n}\n"],"file":"index.js"}