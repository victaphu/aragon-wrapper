{"version":3,"sources":["../../src/cache/index.js"],"names":["Cache","constructor","prefix","Set","forceLocalStorage","configurationKeys","FORCE_LOCAL_STORAGE","drivers","localforage","LOCALSTORAGE","memoryStorageDriver","INDEXEDDB","init","changes","Subject","db","createInstance","driver","name","ready","err","defineDriver","setDriver","_driver","set","key","value","setItem","next","get","defaultValue","getItem","getAll","all","iterate","remove","removeItem","clear","observe","add","getResult$","keyChange$","pipe","change"],"mappings":"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","sourcesContent":["import { Subject, concat, race } from 'rxjs'\nimport { filter, pluck } from 'rxjs/operators'\nimport localforage from 'localforage'\nimport memoryStorageDriver from 'localforage-memoryStorageDriver'\nimport { getConfiguration } from '../configuration'\nimport * as configurationKeys from '../configuration/keys'\n\n/**\n * A persistent cache on browser environments, preferring IndexedDB when available.\n * Falls back to an in-memory cache on node environments.\n *\n * @param {string} prefix\n *        String prefix to use for the cache\n * @param {Object} [options]\n *        Options\n * @param {boolean} [options.forceLocalStorage]\n *        Require the cache to downgrade to localstorage even if IndexedDB is available\n */\nexport default class Cache {\n  #trackedKeys = new Set()\n\n  constructor (prefix) {\n    this.prefix = prefix\n    const forceLocalStorage = getConfiguration(configurationKeys.FORCE_LOCAL_STORAGE)\n    this.drivers = forceLocalStorage\n      ? [localforage.LOCALSTORAGE, memoryStorageDriver]\n      : [localforage.INDEXEDDB, localforage.LOCALSTORAGE, memoryStorageDriver]\n  }\n\n  async init () {\n    // Set up the changes observable\n    this.changes = new Subject()\n\n    // Set up cache DB\n    this.db = localforage.createInstance({\n      driver: this.drivers,\n      name: `localforage/${this.prefix}`\n    })\n\n    try {\n      // Make sure localforage has settled down and is not waiting for anything else\n      // before possibly setting new drivers\n      await this.db.ready()\n    } catch (err) {\n      // If localforage isn't able to automatically connect to a driver\n      // due to lack of support in the environment (e.g. node),\n      // use an in-memory driver instead\n      // TODO: this doesn't provide an persistent cache for node\n      if (this.db.driver() === null) {\n        await this.db.defineDriver(memoryStorageDriver)\n        await this.db.setDriver(memoryStorageDriver._driver)\n      }\n\n      await this.db.ready()\n    }\n  }\n\n  async set (key, value) {\n    await this.db.setItem(\n      key,\n      value\n    )\n\n    this.changes.next({ key, value })\n  }\n\n  async get (key, defaultValue = null) {\n    // If we access a key without data the promise resolve but value is null\n    const value = await this.db.getItem(key)\n    return value || defaultValue\n  }\n\n  async getAll () {\n    const all = {}\n    await this.db.iterate((value, key) => {\n      all[key] = value\n    })\n    return all\n  }\n\n  async remove (key) {\n    await this.db.removeItem(key)\n    this.changes.next({ key, value: null })\n  }\n\n  async clear () {\n    await this.db.clear()\n\n    for (const key of this.#trackedKeys) {\n      this.changes.next({ key, value: null })\n    }\n  }\n\n  /**\n   * Observe the value of a key in cache over time\n   *\n   * @param  {string} key\n   * @param  {*}      defaultValue\n   * @return {Observable}\n   */\n  observe (key, defaultValue) {\n    this.#trackedKeys.add(key)\n\n    const getResult$ = this.get(key, defaultValue)\n    const keyChange$ = this.changes.pipe(\n      filter(change => change.key === key),\n      pluck('value')\n    )\n\n    /*\n     * There is an inherent race between `this.get()` and a new item being set\n     * on the cache key. Note that `concat()` only subscribes to the next observable\n     * **AFTER** the previous one ends (it doesn't buffer hot observables).\n     *\n     * Thus, we either want:\n     *   - The concatenated result of `this.get()` and `this.changes`, if `this.changes`\n     *     doesn't emit new items, or\n     *   - Just `this.changes` since `this.get()` may be stale by the time it returns\n     */\n    return race(concat(getResult$, keyChange$), keyChange$)\n  }\n}\n"],"file":"index.js"}